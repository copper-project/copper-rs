<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `prelude` mod in crate `cu29`."><title>cu29::prelude - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-cf3c48c1.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="cu29" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (4a4309466 2025-02-02)" data-channel="nightly" data-search-js="search-2d513d54.js" data-settings-js="settings-6dad6058.js" ><script src="../../static.files/storage-302de22f.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-9b5d7e41.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../cu29/index.html">cu29</a><span class="version">0.6.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module prelude</a></h2><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#statics" title="Statics">Statics</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li><li><a href="#attributes" title="Attribute Macros">Attribute Macros</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate cu29</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">cu29</a></div><h1>Module <span>prelude</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/cu29/lib.rs.html#19">Source</a> </span></div><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="config/index.html" title="mod cu29::prelude::config">config</a></dt><dd>This module defines the configuration of the copper runtime.
The configuration is a directed graph where nodes are tasks and edges are connections between tasks.
The configuration is serialized in the RON format.
The configuration is used to generate the runtime code at compile time.</dd><dt><a class="mod" href="copperlist/index.html" title="mod cu29::prelude::copperlist">copperlist</a></dt><dd>CopperList is the main data structure used by Copper to communicate between tasks.
It is a queue that can be used to store preallocated messages between tasks in memory order.</dd><dt><a class="mod" href="curuntime/index.html" title="mod cu29::prelude::curuntime">curuntime</a></dt><dd>CuRuntime is the heart of what copper is running on the robot.
It is exposed to the user via the <code>copper_runtime</code> macro injecting it as a field in their application struct.</dd><dt><a class="mod" href="cutask/index.html" title="mod cu29::prelude::cutask">cutask</a></dt><dd>This module contains all the main definition of the traits you need to implement
or interact with to create a Copper task.</dd><dt><a class="mod" href="monitoring/index.html" title="mod cu29::prelude::monitoring">monitoring</a></dt><dd>Some basic internal monitoring tooling Copper uses to monitor itself and the tasks it is running.</dd><dt><a class="mod" href="payload/index.html" title="mod cu29::prelude::payload">payload</a></dt><dt><a class="mod" href="pool/index.html" title="mod cu29::prelude::pool">pool</a></dt><dt><a class="mod" href="simulation/index.html" title="mod cu29::prelude::simulation">simulation</a></dt><dd><code>cu29::simulation</code> Module</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.debug.html" title="macro cu29::prelude::debug">debug</a></dt><dd>This macro is used to log a message with parameters.
The first parameter is a string literal that represents the message to be logged.
Only <code>{}</code> is supported as a placeholder for parameters.
The rest of the parameters are the values to be logged.
The parameters can be named or unnamed.
Named parameters are specified as <code>name = value</code>.
Unnamed parameters are specified as <code>value</code>.</dd><dt><a class="macro" href="macro.gen_cumsgs.html" title="macro cu29::prelude::gen_cumsgs">gen_<wbr>cumsgs</a></dt><dd>Generates the CopperList content type from a config.
gen_cumsgs!(“path/to/config.toml”)
It will create a new type called CuMsgs you can pass to the log reader for decoding:</dd><dt><a class="macro" href="macro.input_msg.html" title="macro cu29::prelude::input_msg">input_<wbr>msg</a></dt><dt><a class="macro" href="macro.output_msg.html" title="macro cu29::prelude::output_msg">output_<wbr>msg</a></dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AlignedBuffer.html" title="struct cu29::prelude::AlignedBuffer">Aligned<wbr>Buffer</a></dt><dd>A buffer that is aligned to a specific size with the Element of type E.</dd><dt><a class="struct" href="struct.Cnx.html" title="struct cu29::prelude::Cnx">Cnx</a></dt><dd>This represents a connection between 2 tasks (nodes) in the configuration graph.</dd><dt><a class="struct" href="struct.ComponentConfig.html" title="struct cu29::prelude::ComponentConfig">Component<wbr>Config</a></dt><dd>This is the configuration of a component (like a task config or a monitoring config):w
It is a map of key-value pairs.
It is given to the new method of the task implementation.</dd><dt><a class="struct" href="struct.CopperContext.html" title="struct cu29::prelude::CopperContext">Copper<wbr>Context</a></dt><dd>Just a simple struct to hold the various bits needed to run a Copper application.</dd><dt><a class="struct" href="struct.CopperLiskMask.html" title="struct cu29::prelude::CopperLiskMask">Copper<wbr>Lisk<wbr>Mask</a></dt><dd>Not implemented yet.
This mask will be used to for example filter out necessary regions of a copper list between remote systems.</dd><dt><a class="struct" href="struct.CopperList.html" title="struct cu29::prelude::CopperList">Copper<wbr>List</a></dt><dt><a class="struct" href="struct.CountingAllocator.html" title="struct cu29::prelude::CountingAllocator">Counting<wbr>Allocator</a></dt><dd>A simple allocator that counts the number of bytes allocated and deallocated.</dd><dt><a class="struct" href="struct.CuArray.html" title="struct cu29::prelude::CuArray">CuArray</a></dt><dd>Copper friendly wrapper for a fixed size array.</dd><dt><a class="struct" href="struct.CuCompactString.html" title="struct cu29::prelude::CuCompactString">CuCompact<wbr>String</a></dt><dt><a class="struct" href="struct.CuConfig.html" title="struct cu29::prelude::CuConfig">CuConfig</a></dt><dd>CuConfig is the programmatic representation of the configuration graph.
It is a directed graph where nodes are tasks and edges are connections between tasks.</dd><dt><a class="struct" href="struct.CuDuration.html" title="struct cu29::prelude::CuDuration">CuDuration</a></dt><dd>For Robot times, the underlying type is a u64 representing nanoseconds.
It is always positive to simplify the reasoning on the user side.</dd><dt><a class="struct" href="struct.CuDurationStatistics.html" title="struct cu29::prelude::CuDurationStatistics">CuDuration<wbr>Statistics</a></dt><dd>A Specialized statistics object for CuDuration.
It will also keep track of the jitter between the values.</dd><dt><a class="struct" href="struct.CuError.html" title="struct cu29::prelude::CuError">CuError</a></dt><dd>Common copper Error type.</dd><dt><a class="struct" href="struct.CuExecutionLoop.html" title="struct cu29::prelude::CuExecutionLoop">CuExecution<wbr>Loop</a></dt><dd>This structure represents a loop in the execution plan.
It is used to represent a sequence of Execution units (loop or steps) that are executed
multiple times.
if loop_count is None, the loop is infinite.</dd><dt><a class="struct" href="struct.CuExecutionStep.html" title="struct cu29::prelude::CuExecutionStep">CuExecution<wbr>Step</a></dt><dd>This structure represents a step in the execution plan.</dd><dt><a class="struct" href="struct.CuHandle.html" title="struct cu29::prelude::CuHandle">CuHandle</a></dt><dd>A shareable handle to an Array coming from a pool (either host or device).</dd><dt><a class="struct" href="struct.CuHostMemoryPool.html" title="struct cu29::prelude::CuHostMemoryPool">CuHost<wbr>Memory<wbr>Pool</a></dt><dd>A pool of host memory buffers.</dd><dt><a class="struct" href="struct.CuListsManager.html" title="struct cu29::prelude::CuListsManager">CuLists<wbr>Manager</a></dt><dd>This structure maintains the entire memory needed by Copper for one loop for the inter tasks communication within a process.
P or Payload is typically a Tuple of various types of messages that are exchanged between tasks.
N is the maximum number of in flight Copper List the runtime can support.</dd><dt><a class="struct" href="struct.CuLogEntry.html" title="struct cu29::prelude::CuLogEntry">CuLog<wbr>Entry</a></dt><dd>This is the basic structure for a log entry in Copper.</dd><dt><a class="struct" href="struct.CuMsg.html" title="struct cu29::prelude::CuMsg">CuMsg</a></dt><dd>CuMsg is the envelope holding the msg payload and the metadata between tasks.</dd><dt><a class="struct" href="struct.CuMsgMetadata.html" title="struct cu29::prelude::CuMsgMetadata">CuMsg<wbr>Metadata</a></dt><dd>CuMsgMetadata is a structure that contains metadata common to all CuMsgs.</dd><dt><a class="struct" href="struct.CuRuntime.html" title="struct cu29::prelude::CuRuntime">CuRuntime</a></dt><dd>This is the main structure that will be injected as a member of the Application struct.
CT is the tuple of all the tasks in order of execution.
CL is the type of the copper list, representing the input/output messages for all the tasks.</dd><dt><a class="struct" href="struct.CuSimSinkTask.html" title="struct cu29::prelude::CuSimSinkTask">CuSim<wbr>Sink<wbr>Task</a></dt><dd>This is a placeholder task for a sink task for the simulations.
It basically does nothing in place of a real driver so it won’t try to initialize any hardware.</dd><dt><a class="struct" href="struct.CuSimSrcTask.html" title="struct cu29::prelude::CuSimSrcTask">CuSim<wbr>SrcTask</a></dt><dd>This is a placeholder task for a source task for the simulations.
It basically does nothing in place of a real driver so it won’t try to initialize any hardware.</dd><dt><a class="struct" href="struct.CuTimeRange.html" title="struct cu29::prelude::CuTimeRange">CuTime<wbr>Range</a></dt><dd>Represents a time range.</dd><dt><a class="struct" href="struct.Instant.html" title="struct cu29::prelude::Instant">Instant</a></dt><dd>A point-in-time wall-clock measurement.</dd><dt><a class="struct" href="struct.LiveStatistics.html" title="struct cu29::prelude::LiveStatistics">Live<wbr>Statistics</a></dt><dd>Accumulative stat object that can give your some real time statistics.</dd><dt><a class="struct" href="struct.LoggerRuntime.html" title="struct cu29::prelude::LoggerRuntime">Logger<wbr>Runtime</a></dt><dd>The lifetime of this struct is the lifetime of the logger.</dd><dt><a class="struct" href="struct.LoggingConfig.html" title="struct cu29::prelude::LoggingConfig">Logging<wbr>Config</a></dt><dt><a class="struct" href="struct.MonitorConfig.html" title="struct cu29::prelude::MonitorConfig">Monitor<wbr>Config</a></dt><dt><a class="struct" href="struct.NoMonitor.html" title="struct cu29::prelude::NoMonitor">NoMonitor</a></dt><dd>A do nothing monitor if no monitor is provided.
This is basically defining the default behavior of Copper in case of error.</dd><dt><a class="struct" href="struct.Node.html" title="struct cu29::prelude::Node">Node</a></dt><dd>A node in the configuration graph.
A node represents a Task in the system Graph.</dd><dt><a class="struct" href="struct.NullLog.html" title="struct cu29::prelude::NullLog">NullLog</a></dt><dt><a class="struct" href="struct.OptionCuTime.html" title="struct cu29::prelude::OptionCuTime">Option<wbr>CuTime</a></dt><dd>Homebrewed <code>Option&lt;CuDuration&gt;</code> to avoid using 128bits just to represent an Option.</dd><dt><a class="struct" href="struct.OwningIoWriter.html" title="struct cu29::prelude::OwningIoWriter">Owning<wbr>IoWriter</a></dt><dt><a class="struct" href="struct.PartialCuTimeRange.html" title="struct cu29::prelude::PartialCuTimeRange">Partial<wbr>CuTime<wbr>Range</a></dt><dd>Represents a time range with possible undefined start or end or both.</dd><dt><a class="struct" href="struct.RobotClock.html" title="struct cu29::prelude::RobotClock">Robot<wbr>Clock</a></dt><dd>A running Robot clock.
The clock is a monotonic clock that starts at an arbitrary reference time.
It is clone resilient, ie a clone will be the same clock, even when mocked.</dd><dt><a class="struct" href="struct.RobotClockMock.html" title="struct cu29::prelude::RobotClockMock">Robot<wbr>Clock<wbr>Mock</a></dt><dd>A mock clock that can be controlled by the user.</dd><dt><a class="struct" href="struct.ScopedAllocCounter.html" title="struct cu29::prelude::ScopedAllocCounter">Scoped<wbr>Alloc<wbr>Counter</a></dt><dd>A simple struct that counts the number of bytes allocated and deallocated in a scope.</dd><dt><a class="struct" href="struct.SectionHandle.html" title="struct cu29::prelude::SectionHandle">Section<wbr>Handle</a></dt><dd>A SectionHandle is a handle to a section in the datalogger.
It allows to track the lifecycle of a section of the datalogger.</dd><dt><a class="struct" href="struct.SectionHeader.html" title="struct cu29::prelude::SectionHeader">Section<wbr>Header</a></dt><dd>Each concurrent sublogger is tracked through a section header.
They form a linked list of sections.
The entry type is used to identify the type of data in the section.</dd><dt><a class="struct" href="struct.SimpleFileWriter.html" title="struct cu29::prelude::SimpleFileWriter">Simple<wbr>File<wbr>Writer</a></dt><dd>This allows this crate to be used outside of Copper (ie. decoupling it from the unifiedlog.</dd><dt><a class="struct" href="struct.UnifiedLoggerBuilder.html" title="struct cu29::prelude::UnifiedLoggerBuilder">Unified<wbr>Logger<wbr>Builder</a></dt><dd>Use this builder to create a new DataLogger.</dd><dt><a class="struct" href="struct.UnifiedLoggerIOReader.html" title="struct cu29::prelude::UnifiedLoggerIOReader">Unified<wbr>LoggerIO<wbr>Reader</a></dt><dd>This a convenience wrapper around the UnifiedLoggerRead to implement the Read trait.</dd><dt><a class="struct" href="struct.UnifiedLoggerRead.html" title="struct cu29::prelude::UnifiedLoggerRead">Unified<wbr>Logger<wbr>Read</a></dt><dd>A read side of the datalogger.</dd><dt><a class="struct" href="struct.UnifiedLoggerWrite.html" title="struct cu29::prelude::UnifiedLoggerWrite">Unified<wbr>Logger<wbr>Write</a></dt><dd>A write side of the datalogger.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.AllocatedSection.html" title="enum cu29::prelude::AllocatedSection">Allocated<wbr>Section</a></dt><dt><a class="enum" href="enum.CopperListState.html" title="enum cu29::prelude::CopperListState">Copper<wbr>List<wbr>State</a></dt><dd>Those are the possible states along the lifetime of a CopperList.</dd><dt><a class="enum" href="enum.CuExecutionUnit.html" title="enum cu29::prelude::CuExecutionUnit">CuExecution<wbr>Unit</a></dt><dd>This structure represents a step in the execution plan.</dd><dt><a class="enum" href="enum.CuHandleInner.html" title="enum cu29::prelude::CuHandleInner">CuHandle<wbr>Inner</a></dt><dd>A Handle to a Buffer.
For onboard usages, the buffer should be Pooled (ie, coming from a preallocated pool).
The Detached version is for offline usages where we don’t really need a pool to deserialize them.</dd><dt><a class="enum" href="enum.CuTaskCallbackState.html" title="enum cu29::prelude::CuTaskCallbackState">CuTask<wbr>Callback<wbr>State</a></dt><dd>This is the state that will be passed to the simulation support to hook
into the lifecycle of the tasks.</dd><dt><a class="enum" href="enum.CuTaskState.html" title="enum cu29::prelude::CuTaskState">CuTask<wbr>State</a></dt><dd>The state of a task.</dd><dt><a class="enum" href="enum.CuTaskType.html" title="enum cu29::prelude::CuTaskType">CuTask<wbr>Type</a></dt><dd>Copper tasks can be of 3 types:</dd><dt><a class="enum" href="enum.Decision.html" title="enum cu29::prelude::Decision">Decision</a></dt><dd>Monitor decision to be taken when a task errored out.</dd><dt><a class="enum" href="enum.SimOverride.html" title="enum cu29::prelude::SimOverride">SimOverride</a></dt><dd>This is the answer the simulator can give to control the simulation flow.</dd><dt><a class="enum" href="enum.Tov.html" title="enum cu29::prelude::Tov">Tov</a></dt><dd>The time of validity of a message can be more than one time but can be a time range of Tovs.
For example a sub scan for a lidar, a set of images etc… can have a range of validity.</dd><dt><a class="enum" href="enum.UnifiedLogType.html" title="enum cu29::prelude::UnifiedLogType">Unified<wbr>LogType</a></dt><dd>Defines the types of what can be logged in the unified logger.</dd><dt><a class="enum" href="enum.UnifiedLogger.html" title="enum cu29::prelude::UnifiedLogger">Unified<wbr>Logger</a></dt><dd>Holder of the read or write side of the datalogger.</dd><dt><a class="enum" href="enum.Value.html" title="enum cu29::prelude::Value">Value</a></dt></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.ANONYMOUS.html" title="constant cu29::prelude::ANONYMOUS">ANONYMOUS</a></dt><dt><a class="constant" href="constant.MAX_LOG_PARAMS_ON_STACK.html" title="constant cu29::prelude::MAX_LOG_PARAMS_ON_STACK">MAX_<wbr>LOG_<wbr>PARAMS_<wbr>ON_<wbr>STACK</a></dt></dl><h2 id="statics" class="section-header">Statics<a href="#statics" class="anchor">§</a></h2><dl class="item-table"><dt><a class="static" href="static.EXTRA_TEXT_LOGGER.html" title="static cu29::prelude::EXTRA_TEXT_LOGGER">EXTRA_<wbr>TEXT_<wbr>LOGGER</a></dt><dt><a class="static" href="static.GLOBAL.html" title="static cu29::prelude::GLOBAL">GLOBAL</a></dt></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.ArrayLike.html" title="trait cu29::prelude::ArrayLike">Array<wbr>Like</a></dt><dt><a class="trait" href="trait.ClockProvider.html" title="trait cu29::prelude::ClockProvider">Clock<wbr>Provider</a></dt><dd>A trait to provide a clock to the runtime.</dd><dt><a class="trait" href="trait.CopperListTuple.html" title="trait cu29::prelude::CopperListTuple">Copper<wbr>List<wbr>Tuple</a></dt><dd>A CopperListTuple needs to be encodable, decodable and fixed size in memory.</dd><dt><a class="trait" href="trait.CuMonitor.html" title="trait cu29::prelude::CuMonitor">CuMonitor</a></dt><dd>Trait to implement a monitoring task.</dd><dt><a class="trait" href="trait.CuMsgPack.html" title="trait cu29::prelude::CuMsgPack">CuMsg<wbr>Pack</a></dt><dt><a class="trait" href="trait.CuMsgPayload.html" title="trait cu29::prelude::CuMsgPayload">CuMsg<wbr>Payload</a></dt><dt><a class="trait" href="trait.CuPool.html" title="trait cu29::prelude::CuPool">CuPool</a></dt><dd>A CuPool is a pool of buffers that can be shared between different parts of the code.
Handles can be stored locally in the tasks and shared between them.</dd><dt><a class="trait" href="trait.CuSinkTask.html" title="trait cu29::prelude::CuSinkTask">CuSink<wbr>Task</a></dt><dd>A Sink Task is a task that only consumes messages. For example drivers for actuators are Sink Tasks.</dd><dt><a class="trait" href="trait.CuSrcTask.html" title="trait cu29::prelude::CuSrcTask">CuSrc<wbr>Task</a></dt><dd>A Src Task is a task that only produces messages. For example drivers for sensors are Src Tasks.
They are in push mode from the runtime.
To set the frequency of the pulls and align them to any hw, see the runtime configuration.
Note: A source has the privilege to have a clock passed to it vs a frozen clock.</dd><dt><a class="trait" href="trait.CuTask.html" title="trait cu29::prelude::CuTask">CuTask</a></dt><dd>This is the most generic Task of copper. It is a “transform” task deriving an output from an input.</dd><dt><a class="trait" href="trait.DeviceCuPool.html" title="trait cu29::prelude::DeviceCuPool">Device<wbr>CuPool</a></dt><dd>A device memory pool can copy data from a device to a host memory pool on top.</dd><dt><a class="trait" href="trait.ElementType.html" title="trait cu29::prelude::ElementType">Element<wbr>Type</a></dt><dd>Basic Type that can be used in a buffer in a CuPool.</dd><dt><a class="trait" href="trait.Freezable.html" title="trait cu29::prelude::Freezable">Freezable</a></dt><dd>The internal state of a task needs to be serializable
so the framework can take a snapshot of the task graph.</dd><dt><a class="trait" href="trait.PoolMonitor.html" title="trait cu29::prelude::PoolMonitor">Pool<wbr>Monitor</a></dt><dd>Trait for a Pool to exposed to be monitored by the monitoring API.</dd><dt><a class="trait" href="trait.WriteStream.html" title="trait cu29::prelude::WriteStream">Write<wbr>Stream</a></dt><dd>Defines a basic write, append only stream trait to be able to log or send serializable objects.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.compute_runtime_plan.html" title="fn cu29::prelude::compute_runtime_plan">compute_<wbr>runtime_<wbr>plan</a></dt><dd>This is the main heuristics to compute an execution plan at compilation time.
TODO: Make that heuristic pluggable.</dd><dt><a class="fn" href="fn.default_log_index_dir.html" title="fn cu29::prelude::default_log_index_dir">default_<wbr>log_<wbr>index_<wbr>dir</a></dt><dd>Convenience function to returns the default path for the log index directory.</dd><dt><a class="fn" href="fn.find_task_type_for_id.html" title="fn cu29::prelude::find_task_type_for_id">find_<wbr>task_<wbr>type_<wbr>for_<wbr>id</a></dt><dt><a class="fn" href="fn.format_logline.html" title="fn cu29::prelude::format_logline">format_<wbr>logline</a></dt><dd>Text log line formatter.</dd><dt><a class="fn" href="fn.log.html" title="fn cu29::prelude::log">log</a></dt><dd>Function called from generated code to log data.
It moves entry by design, it will be absorbed in the queue.</dd><dt><a class="fn" href="fn.log_debug_mode.html" title="fn cu29::prelude::log_debug_mode">log_<wbr>debug_<wbr>mode</a></dt><dd>This version of log is only compiled in debug mode
This allows a normal logging framework to be bridged.</dd><dt><a class="fn" href="fn.pools_statistics.html" title="fn cu29::prelude::pools_statistics">pools_<wbr>statistics</a></dt><dd>Get the list of pools and their statistics.
We use SmallVec here to avoid heap allocations while the stack is running.</dd><dt><a class="fn" href="fn.read_configuration.html" title="fn cu29::prelude::read_configuration">read_<wbr>configuration</a></dt><dd>Read a copper configuration from a file.</dd><dt><a class="fn" href="fn.read_configuration_str.html" title="fn cu29::prelude::read_configuration_str">read_<wbr>configuration_<wbr>str</a></dt><dd>Read a copper configuration from a String.</dd><dt><a class="fn" href="fn.read_interned_strings.html" title="fn cu29::prelude::read_interned_strings">read_<wbr>interned_<wbr>strings</a></dt><dd>Rebuild the interned string index in memory.</dd><dt><a class="fn" href="fn.rebuild_logline.html" title="fn cu29::prelude::rebuild_logline">rebuild_<wbr>logline</a></dt><dd>Rebuild a log line from the interned strings and the CuLogEntry.
This basically translates the world of copper logs to text logs.</dd><dt><a class="fn" href="fn.stream_write.html" title="fn cu29::prelude::stream_write">stream_<wbr>write</a></dt><dd>Create a new stream to write to the unifiedlogger.</dd><dt><a class="fn" href="fn.to_value.html" title="fn cu29::prelude::to_value">to_<wbr>value</a></dt></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.AscIter.html" title="type cu29::prelude::AscIter">AscIter</a></dt><dt><a class="type" href="type.AscIterMut.html" title="type cu29::prelude::AscIterMut">AscIter<wbr>Mut</a></dt><dt><a class="type" href="type.CuResult.html" title="type cu29::prelude::CuResult">CuResult</a></dt><dt><a class="type" href="type.CuTime.html" title="type cu29::prelude::CuTime">CuTime</a></dt><dd>A robot time is just a duration from a fixed point in time.</dd><dt><a class="type" href="type.Iter.html" title="type cu29::prelude::Iter">Iter</a></dt><dt><a class="type" href="type.IterMut.html" title="type cu29::prelude::IterMut">IterMut</a></dt><dt><a class="type" href="type.NodeId.html" title="type cu29::prelude::NodeId">NodeId</a></dt><dd>NodeId is the unique identifier of a node in the configuration graph for petgraph
and the code generation.</dd></dl><h2 id="attributes" class="section-header">Attribute Macros<a href="#attributes" class="anchor">§</a></h2><dl class="item-table"><dt><a class="attr" href="attr.copper_runtime.html" title="attr cu29::prelude::copper_runtime">copper_<wbr>runtime</a></dt><dd>Adds #[copper_runtime(config = “path”, sim_mode = false/true)] to your application struct to generate the runtime.
if sim_mode is omitted, it is set to false.
This will add a “runtime” field to your struct and implement the “new” and “run” methods.</dd></dl></section></div></main></body></html>