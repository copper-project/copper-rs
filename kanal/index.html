<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Kanal"><title>kanal - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="kanal" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.0 (051478957 2024-07-21)" data-channel="1.80.0" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../kanal/index.html">kanal</a><span class="version">0.1.0-pre8</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">kanal</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/kanal/lib.rs.html#1-1552">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="kanal"><a class="doc-anchor" href="#kanal">§</a>Kanal</h2>
<p><strong>The fast sync and async channel that Rust deserves!</strong></p>
<p><a href="https://crates.io/crates/kanal"><img src="https://img.shields.io/crates/v/kanal.svg" alt="Crates.io" /></a>
<a href="https://docs.rs/kanal"><img src="https://docs.rs/kanal/badge.svg" alt="Documentation" /></a>
<a href="https://github.com/fereidani/kanal/blob/master/LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="MIT licensed" /></a></p>
<h3 id="what-is-kanal"><a class="doc-anchor" href="#what-is-kanal">§</a>What is Kanal</h3>
<p>The Kanal library is a Rust implementation of channels of the CSP (Communicating Sequential Processes) model, designed to assist programmers in creating efficient concurrent programs. This library provides multi-producer and multi-consumer channels with advanced features and lock-free one-shot channels that only allocate the size of a pointer in the heap, allowing for fast communication. The library has a focus on unifying message passing between synchronous and asynchronous portions of Rust code through a combination of synchronous and asynchronous APIs while maintaining high performance.</p>
<h3 id="why-kanal-is-faster"><a class="doc-anchor" href="#why-kanal-is-faster">§</a>Why Kanal is faster?</h3>
<ol>
<li>Kanal employs a highly optimized composite technique for the transfer of objects. When the data size is less than or equal to the pointer size, it utilizes serialization, encoding the data as the pointer address. Conversely, when the data size exceeds the pointer size, the protocol employs a strategy similar to that utilized by the Golang programming language, utilizing direct memory access to copy objects from the sender’s stack or write directly to the receiver’s stack. This composite method not only eliminates unnecessary pointer access but also eliminates heap allocations for bounded(0) channels.</li>
<li>Kanal utilizes a specially tuned mutex for its channel locking mechanism, made possible by the predictable internal lock time of the channel. That said it’s possible to use Rust standard mutex with the <code>std-mutex</code> feature and Kanal will perform better than competitors with that feature too.</li>
<li>Utilizing Rust high-performance compiler and powerful LLVM backend with highly optimized memory access and deeply thought algorithms.</li>
</ol>
<h3 id="why-use-kanal"><a class="doc-anchor" href="#why-use-kanal">§</a>Why use Kanal?</h3>
<ul>
<li>Kanal is fast and efficient in communication</li>
<li>Kanal can communicate in both sync and async and even between sync and async by providing methods to transform sender/receiver to other API.</li>
<li>Kanal provides cleaner API in comparison with other rust libraries</li>
<li>Similar to Golang you have access to the <code>Close</code> function and you can broadcast the close signal from any instance of the channel, to close the channel for both sides.</li>
<li>Kanal provides high-performance MPMC channels and lock-free one-shot channels in one package.</li>
</ul>
<h3 id="why-not-use-kanal"><a class="doc-anchor" href="#why-not-use-kanal">§</a>Why not use Kanal?</h3>
<ul>
<li>Kanal developers are trying their best to audit the small codebase of Kanal and make sure there is no undefined behavior. Kanal is using Unsafe. If you are not ok with that in your project we suggest using safe-only alternatives.</li>
</ul>
<h4 id="benchmark-results"><a class="doc-anchor" href="#benchmark-results">§</a>Benchmark Results</h4>
<p>Results are based on how many messages can be passed in each scenario per second.</p>
<h5 id="test-types"><a class="doc-anchor" href="#test-types">§</a>Test types:</h5>
<ol>
<li>Seq is sequentially writing and reading to a channel in the same thread.</li>
<li>SPSC is one receiver, and one sender and passing messages between them.</li>
<li>MPSC is multiple sender threads with only one receiver.</li>
<li>MPMC is multiple senders and multiple receivers communicating through the same channel.</li>
</ol>
<h5 id="message-types"><a class="doc-anchor" href="#message-types">§</a>Message types:</h5>
<ol>
<li><code>usize</code> tests are transferring messages of size hardware pointer.</li>
<li><code>big</code> tests are transferring messages of 8x the size of the hardware pointer.</li>
</ol>
<p>N/A means that the test subject is unable to perform the test due to its limitations, Some of the test subjects don’t have implementation for size 0 channels, MPMC or unbounded channels.</p>
<p>Machine: <code>AMD Ryzen Threadripper 2950X 16-Core Processor</code><br />
Rust: <code>rustc 1.66.1 (90743e729 2023-01-10)</code><br />
Go: <code>go version go1.19.5 linux/amd64</code><br />
OS (<code>uname -a</code>): <code>Linux 5.15.0-58-generic #64~20.04.1-Ubuntu SMP Fri Jan 6 16:42:31 UTC 2023 x86_64</code><br />
Date: Jan 25, 2023</p>
<p><a href="https://github.com/fereidani/rust-channel-benchmarks">Benchmark codes</a></p>
<p><img src="https://i.imgur.com/ReEQWKa.png" alt="Benchmarks" /></p>
<h5 id="why-async-outperforms-sync-in-some-tests"><a class="doc-anchor" href="#why-async-outperforms-sync-in-some-tests">§</a>Why async outperforms sync in some tests?</h5>
<p>In certain tests, asynchronous communication may exhibit superior performance compared to synchronous communication. This can be attributed to the context-switching performance of libraries such as tokio, which, similar to Golang, utilize context-switching within the same thread to switch to the next coroutine when a message is ready on a channel. This approach is more efficient than communicating between separate threads. This same principle applies to asynchronous network applications, which generally exhibit better performance compared to synchronous implementations. As the channel size increases, one may observe improved performance in synchronous benchmarks, as the sending threads are able to push data directly to the channel queue without requiring awaiting blocking/suspending signals from receiving threads.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AsyncReceiver.html" title="struct kanal::AsyncReceiver">AsyncReceiver</a></div><div class="desc docblock-short"><a href="struct.AsyncReceiver.html" title="struct kanal::AsyncReceiver"><code>AsyncReceiver</code></a> is receiving side of the channel in async mode.
Receivers can be cloned and produce receivers to operate in both sync and
async modes.</div></li><li><div class="item-name"><a class="struct" href="struct.AsyncSender.html" title="struct kanal::AsyncSender">AsyncSender</a></div><div class="desc docblock-short">Sending side of the channel with async API.  It’s possible to convert it to
sync <a href="struct.Sender.html" title="struct kanal::Sender"><code>Sender</code></a> with <code>as_sync</code>, <code>to_sync</code> or <code>clone_sync</code> based on software
requirement.</div></li><li><div class="item-name"><a class="struct" href="struct.OneshotAsyncReceiver.html" title="struct kanal::OneshotAsyncReceiver">OneshotAsyncReceiver</a></div><div class="desc docblock-short"><a href="struct.OneshotAsyncReceiver.html" title="struct kanal::OneshotAsyncReceiver"><code>OneshotAsyncReceiver&lt;T&gt;</code></a> is the receiver side of oneshot channel that can
receive a single message asynchronously. It can be converted to
<a href="struct.OneshotReceiver.html" title="struct kanal::OneshotReceiver"><code>OneshotReceiver&lt;T&gt;</code></a> by calling <a href="struct.OneshotAsyncReceiver.html#method.to_sync" title="method kanal::OneshotAsyncReceiver::to_sync"><code>Self::to_sync</code></a>. Receiving a message is
achievable with <a href="struct.OneshotAsyncReceiver.html#method.recv" title="method kanal::OneshotAsyncReceiver::recv"><code>Self::recv</code></a> which returns a future that should be polled
to receive the message.</div></li><li><div class="item-name"><a class="struct" href="struct.OneshotAsyncSender.html" title="struct kanal::OneshotAsyncSender">OneshotAsyncSender</a></div><div class="desc docblock-short"><a href="struct.OneshotAsyncSender.html" title="struct kanal::OneshotAsyncSender"><code>OneshotAsyncSender&lt;T&gt;</code></a> is the sender side of oneshot channel that can
send a single message asynchronously. It can be converted to
<a href="struct.OneshotSender.html" title="struct kanal::OneshotSender"><code>OneshotSender&lt;T&gt;</code></a> by calling <a href="struct.OneshotAsyncSender.html#method.to_sync" title="method kanal::OneshotAsyncSender::to_sync"><code>Self::to_sync</code></a>. Sending a message is
achievable with <a href="struct.OneshotAsyncSender.html#method.send" title="method kanal::OneshotAsyncSender::send"><code>Self::send</code></a> which returns a future that should be polled
until transfer is done.</div></li><li><div class="item-name"><a class="struct" href="struct.OneshotReceiveError.html" title="struct kanal::OneshotReceiveError">OneshotReceiveError</a></div><div class="desc docblock-short">Error type for oneshot channel receive failed operation</div></li><li><div class="item-name"><a class="struct" href="struct.OneshotReceiveFuture.html" title="struct kanal::OneshotReceiveFuture">OneshotReceiveFuture</a></div><div class="desc docblock-short">Oneshot channel receive future that asynchronously receives data from
oneshot sender</div></li><li><div class="item-name"><a class="struct" href="struct.OneshotReceiver.html" title="struct kanal::OneshotReceiver">OneshotReceiver</a></div><div class="desc docblock-short"><a href="struct.OneshotReceiver.html" title="struct kanal::OneshotReceiver"><code>OneshotReceiver&lt;T&gt;</code></a> is the receiver side of oneshot channel that can
receive a single message. It can be converted to async
<a href="struct.OneshotAsyncReceiver.html" title="struct kanal::OneshotAsyncReceiver"><code>OneshotAsyncReceiver&lt;T&gt;</code></a> by calling <a href="struct.OneshotReceiver.html#method.to_async" title="method kanal::OneshotReceiver::to_async"><code>Self::to_async</code></a>. Receiving a
message is achievable with <a href="struct.OneshotReceiver.html#method.recv" title="method kanal::OneshotReceiver::recv"><code>Self::recv</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.OneshotSendFuture.html" title="struct kanal::OneshotSendFuture">OneshotSendFuture</a></div><div class="desc docblock-short">Oneshot channel send future that asynchronously sends data to the oneshot
receiver. returns <code>Ok(())</code> and in case of failure it returns back the
sending object as <code>Err(T)</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.OneshotSender.html" title="struct kanal::OneshotSender">OneshotSender</a></div><div class="desc docblock-short"><a href="struct.OneshotSender.html" title="struct kanal::OneshotSender"><code>OneshotSender&lt;T&gt;</code></a> is the sender side of oneshot channel that can send a
single message. It can be converted to async <a href="struct.OneshotAsyncSender.html" title="struct kanal::OneshotAsyncSender"><code>OneshotAsyncSender&lt;T&gt;</code></a> by
calling <a href="struct.OneshotSender.html#method.to_async" title="method kanal::OneshotSender::to_async"><code>Self::to_async</code></a>. Sending a message is achievable with
<a href="struct.OneshotSender.html#method.send" title="method kanal::OneshotSender::send"><code>Self::send</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.ReceiveFuture.html" title="struct kanal::ReceiveFuture">ReceiveFuture</a></div><div class="desc docblock-short">Receive future to receive an object from the channel asynchronously
It must be polled to perform receive action</div></li><li><div class="item-name"><a class="struct" href="struct.ReceiveStream.html" title="struct kanal::ReceiveStream">ReceiveStream</a></div><div class="desc docblock-short">Receive stream</div></li><li><div class="item-name"><a class="struct" href="struct.Receiver.html" title="struct kanal::Receiver">Receiver</a></div><div class="desc docblock-short">Receiving side of the channel in sync mode.
Receivers can be cloned and produce receivers to operate in both sync and
async modes.</div></li><li><div class="item-name"><a class="struct" href="struct.SendFuture.html" title="struct kanal::SendFuture">SendFuture</a></div><div class="desc docblock-short">Send future to send an object to the channel asynchronously
It must be polled to perform send action</div></li><li><div class="item-name"><a class="struct" href="struct.Sender.html" title="struct kanal::Sender">Sender</a></div><div class="desc docblock-short">Sending side of the channel with sync API. It’s possible to convert it to
async <a href="struct.AsyncSender.html" title="struct kanal::AsyncSender"><code>AsyncSender</code></a> with <code>as_async</code>, <code>to_async</code> or <code>clone_async</code> based on
software requirement.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.ReceiveError.html" title="enum kanal::ReceiveError">ReceiveError</a></div><div class="desc docblock-short">Error type for channel receive operations without timeout</div></li><li><div class="item-name"><a class="enum" href="enum.ReceiveErrorTimeout.html" title="enum kanal::ReceiveErrorTimeout">ReceiveErrorTimeout</a></div><div class="desc docblock-short">Error type for channel receive operations with timeout</div></li><li><div class="item-name"><a class="enum" href="enum.SendError.html" title="enum kanal::SendError">SendError</a></div><div class="desc docblock-short">Error type for channel send operations without timeout</div></li><li><div class="item-name"><a class="enum" href="enum.SendErrorTimeout.html" title="enum kanal::SendErrorTimeout">SendErrorTimeout</a></div><div class="desc docblock-short">Error type for channel send operations with timeout</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.bounded.html" title="fn kanal::bounded">bounded</a></div><div class="desc docblock-short">Creates a new sync bounded channel with the requested buffer size, and
returns <a href="struct.Sender.html" title="struct kanal::Sender"><code>Sender</code></a> and <a href="struct.Receiver.html" title="struct kanal::Receiver"><code>Receiver</code></a> of the channel for type T, you can get
access to async API of <a href="struct.AsyncSender.html" title="struct kanal::AsyncSender"><code>AsyncSender</code></a> and <a href="struct.AsyncReceiver.html" title="struct kanal::AsyncReceiver"><code>AsyncReceiver</code></a> with <code>to_sync</code>,
<code>as_async</code> or <code>clone_sync</code> based on your requirements, by calling them on
sender or receiver.</div></li><li><div class="item-name"><a class="fn" href="fn.bounded_async.html" title="fn kanal::bounded_async">bounded_async</a></div><div class="desc docblock-short">Creates a new async bounded channel with the requested buffer size, and
returns <a href="struct.AsyncSender.html" title="struct kanal::AsyncSender"><code>AsyncSender</code></a> and <a href="struct.AsyncReceiver.html" title="struct kanal::AsyncReceiver"><code>AsyncReceiver</code></a> of the channel for type T, you
can get access to sync API of <a href="struct.Sender.html" title="struct kanal::Sender"><code>Sender</code></a> and <a href="struct.Receiver.html" title="struct kanal::Receiver"><code>Receiver</code></a> with <code>to_sync</code>,
<code>as_async</code> or <code>clone_sync</code> based on your requirements, by calling them on
async sender or receiver.</div></li><li><div class="item-name"><a class="fn" href="fn.oneshot.html" title="fn kanal::oneshot">oneshot</a></div><div class="desc docblock-short">Creates new oneshot channel and returns the <a href="struct.OneshotSender.html" title="struct kanal::OneshotSender"><code>OneshotSender&lt;T&gt;</code></a> and
<a href="struct.OneshotReceiver.html" title="struct kanal::OneshotReceiver"><code>OneshotReceiver&lt;T&gt;</code></a> for it.</div></li><li><div class="item-name"><a class="fn" href="fn.oneshot_async.html" title="fn kanal::oneshot_async">oneshot_async</a></div><div class="desc docblock-short">Creates new oneshot channel and returns the async <a href="struct.OneshotAsyncSender.html" title="struct kanal::OneshotAsyncSender"><code>OneshotAsyncSender&lt;T&gt;</code></a>
and <a href="struct.OneshotAsyncReceiver.html" title="struct kanal::OneshotAsyncReceiver"><code>OneshotAsyncReceiver&lt;T&gt;</code></a> for it.</div></li><li><div class="item-name"><a class="fn" href="fn.unbounded.html" title="fn kanal::unbounded">unbounded</a></div><div class="desc docblock-short">Creates a new sync unbounded channel, and returns <a href="struct.Sender.html" title="struct kanal::Sender"><code>Sender</code></a> and
<a href="struct.Receiver.html" title="struct kanal::Receiver"><code>Receiver</code></a> of the channel for type T, you can get access to async API
of <a href="struct.AsyncSender.html" title="struct kanal::AsyncSender"><code>AsyncSender</code></a> and <a href="struct.AsyncReceiver.html" title="struct kanal::AsyncReceiver"><code>AsyncReceiver</code></a> with <code>to_sync</code>, <code>as_async</code> or
<code>clone_sync</code> based on your requirements, by calling them on sender or
receiver.</div></li><li><div class="item-name"><a class="fn" href="fn.unbounded_async.html" title="fn kanal::unbounded_async">unbounded_async</a></div><div class="desc docblock-short">Creates a new async unbounded channel, and returns <a href="struct.AsyncSender.html" title="struct kanal::AsyncSender"><code>AsyncSender</code></a> and
<a href="struct.AsyncReceiver.html" title="struct kanal::AsyncReceiver"><code>AsyncReceiver</code></a> of the channel for type T, you can get access to sync API
of <a href="struct.Sender.html" title="struct kanal::Sender"><code>Sender</code></a> and <a href="struct.Receiver.html" title="struct kanal::Receiver"><code>Receiver</code></a> with <code>to_sync</code>, <code>as_async</code> or <code>clone_sync</code>
based on your requirements, by calling them on async sender or receiver.</div></li></ul></section></div></main></body></html>