searchState.loadedDescShard("cu29", 0, "copper GitHub last commit  dependency status License …\nA CopperListTuple needs to be encodable, decodable and …\nCommon copper Error type.\nKey metadata piece attached to every message in Copper.\nA generic trait to expose the generated CuStampedDataSet …\nTrait to get a vector of type-erased CuStampedDataSet This …\nContains the error value\nTrait to trace back from the CopperList the origin of the …\nRepresent the minimum set of traits to be usable as …\nContains the success value\nDefines the types of what can be logged in the unified …\nDefines a basic write, append only stream trait to be able …\nThis module defines the configuration of the copper …\nCopperList is the main data structure used by Copper to …\nCuRuntime is the heart of what copper is running on the …\nThis module contains all the main definition of the traits …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSome basic internal monitoring tooling Copper uses to …\nThe time range used for the processing of this message\nRead a copper configuration from a file.\n<code>cu29::simulation</code> Module\nSmall status text for user UI to get the realtime state of …\nThis represents a connection between 2 tasks (nodes) in …\nThis is the configuration of a component (like a task …\nCuConfig is the programmatic representation of the …\nIncludes are used to include other configuration files.\nMissions are used to generate alternative DAGs within the …\nA node in the configuration graph. A node represents a …\nNodeId is the unique identifier of a node in the …\nWrapper around the ron::Value to allow for custom …\nEnable task logging to the log file.\nReturns the argument unchanged.\nGraph structure - either a single graph or multiple …\nCalls <code>U::from(self)</code>.\nInterval in copperlists between two “keyframes” in the …\nOptional logging configuration\nRestrict this connection for this list of missions.\nOptional monitoring configuration\nMessage type exchanged between src and dst.\nRead a copper configuration from a file.\nPre-allocated size for each section in the log file.\nSize of each slab in the log file. (it is the size of the …\nTells Copper if it needs to log the messages.\nNot implemented yet. This mask will be used to for example …\nThose are the possible states along the lifetime of a …\nThis structure maintains the entire memory needed by …\nJust a simple struct to hold the various bits needed to …\nManages the lifecycle of the copper lists and logging.\nThis structure represents a loop in the execution plan. It …\nThis structure represents a step in the execution plan.\nThis structure represents a step in the execution plan.\nThis is the main structure that will be injected as a …\nCopper tasks can be of 3 types:\nA KeyFrame is recording a snapshot of the tasks state …\nManages the frozen tasks state and logging.\nThe base clock the runtime will be using to record time.\nThis is the main heuristics to compute an execution plan …\nThe logger for the copper lists (messages between tasks)\nthe indices in the copper list of the input messages and …\nThe logger for the state of the tasks (frozen tasks)\nLogger for the copper lists (messages between tasks)\nThe runtime monitoring.\nNode: node instance\nNodeId: node id of the task to execute\nthe index in the copper list of the output message and its …\nCuTaskType: type of the task\nThe tuple of all the tasks in order of execution.\nBincode Adapter for Freezable tasks This allows the use of …\nCuMsgMetadata is a structure that contains metadata common …\nA Sink Task is a task that only consumes messages. For …\nA Src Task is a task that only produces messages. For …\nCuMsg is the envelope holding the msg payload and the …\nThis is the most generic Task of copper. It is a “…\nThe internal state of a task needs to be serializable so …\nThis metadata is the data that is common to all messages.\nHere you need to initialize everything your task will need …\nHere you need to initialize everything your task will need …\nHere you need to initialize everything your task will need …\nProcess is the most critical execution of the task. The …\nProcess is the most critical execution of the task. The …\nProcess is the most critical execution of the task. The …\nThe time range used for the processing of this message\nA small string for real time feedback purposes. This is …\nThe time of validity of the message. It can be undefined …\nA simple allocator that counts the number of bytes …\nA Specialized statistics object for CuDuration. It will …\nTrait to implement a monitoring task.\nThe state of a task.\nMonitor decision to be taken when a task errored out.\nAccumulative stat object that can give your some real time …\nA do nothing monitor if no monitor is provided. This is …\nA simple struct that counts the number of bytes allocated …\nCallback that will be trigger at the end of every …\nCallbacked when a Task errored out. The runtime requires …\nCopper friendly wrapper for a fixed size array.\nA Copper-friendly wrapper around ArrayVec with bincode …\nA buffer that is aligned to a specific size with the …\nBincode Adapter for Freezable tasks This allows the use of …\nA trait to provide a clock to the runtime.\nThis represents a connection between 2 tasks (nodes) in …\nThis is the configuration of a component (like a task …\nJust a simple struct to hold the various bits needed to …\nNot implemented yet. This mask will be used to for example …\nThose are the possible states along the lifetime of a …\nA CopperListTuple needs to be encodable, decodable and …\nManages the lifecycle of the copper lists and logging.\nA simple allocator that counts the number of bytes …\nCritical errors requiring immediate attention, usually …\nA trait that defines the structure and behavior of a …\nCopper friendly wrapper for a fixed size array.\nA Copper-friendly wrapper around ArrayVec with bincode …\nCuConfig is the programmatic representation of the …\nFor Robot times, the underlying type is a u64 representing …\nA Specialized statistics object for CuDuration. It will …\nCommon copper Error type.\nThis structure represents a loop in the execution plan. It …\nThis structure represents a step in the execution plan.\nThis structure represents a step in the execution plan.\nA shareable handle to an Array coming from a pool (either …\nA Handle to a Buffer. For onboard usages, the buffer …\nA pool of host memory buffers.\nThis structure maintains the entire memory needed by …\nThis is the basic structure for a log entry in Copper.\nLog levels for Copper.\nTrait to implement a monitoring task.\nCuMsgMetadata is a structure that contains metadata common …\nKey metadata piece attached to every message in Copper.\nA CuPool is a pool of buffers that can be shared between …\nThis is the main structure that will be injected as a …\nA trait that defines the structure and behavior of a …\nThis is a placeholder task for a sink task for the …\nThis is a placeholder task for a source task for the …\nA Sink Task is a task that only consumes messages. For …\nA Src Task is a task that only produces messages. For …\nCuMsg is the envelope holding the msg payload and the …\nThis is the most generic Task of copper. It is a “…\nThis is the state that will be passed to the simulation …\nThe state of a task.\nCopper tasks can be of 3 types:\nA robot time is just a duration from a fixed point in time.\nRepresents a time range.\nDetailed information useful during development\nMonitor decision to be taken when a task errored out.\nA device memory pool can copy data from a device to a host …\nBasic Type that can be used in a buffer in a CuPool.\nA generic trait to expose the generated CuStampedDataSet …\nTrait to get a vector of type-erased CuStampedDataSet This …\nContains the error value\nIssues that might disrupt normal operation but don’t …\nEmulated the behavior of an erroring task (same as return …\nThe actual implementation needs to be executed.\nThe callback took care of the logic on the simulation side …\nThe internal state of a task needs to be serializable so …\nIncludes are used to include other configuration files.\nGeneral information about system operation\nA point-in-time wall-clock measurement.\nA KeyFrame is recording a snapshot of the tasks state …\nManages the frozen tasks state and logging.\nAccumulative stat object that can give your some real time …\nThe lifetime of this struct is the lifetime of the logger.\nThe main file header of the datalogger.\nTrait to trace back from the CopperList the origin of the …\nRepresent the minimum set of traits to be usable as …\nMissions are used to generate alternative DAGs within the …\nCallbacked when a task is created. It gives you the …\nA do nothing monitor if no monitor is provided. This is …\nA node in the configuration graph. A node represents a …\nNodeId is the unique identifier of a node in the …\nContains the success value\nHomebrewed <code>Option&lt;CuDuration&gt;</code> to avoid using 128bits just …\nRepresents a time range with possible undefined start or …\nTrait for a Pool to exposed to be monitored by the …\nCallbacked when a task is getting called on post-process.\nCallbacked when a task is getting called on pre-process.\nCallbacked when a task is getting called on process. I and …\nA running Robot clock. The clock is a monotonic clock that …\nA mock clock that can be controlled by the user.\nA simple struct that counts the number of bytes allocated …\nA SectionHandle is a handle to a section in the datalogger.\nEach concurrent sublogger is tracked through a section …\nA <strong>data structure</strong> that can be serialized into any data …\nThis is the answer the simulator can give to control the …\nThis allows this crate to be used outside of Copper (ie. …\nCallbacked when a task is started.\nThe type representing a simulation step that can be …\nCallbacked when a task is stopped.\nThe time of validity of a message can be more than one …\nDefines the types of what can be logged in the unified …\nHolder of the read or write side of the datalogger.\nUse this builder to create a new DataLogger.\nThis a convenience wrapper around the UnifiedLoggerRead to …\nA read side of the datalogger.\nA write side of the datalogger.\nIndication of potential issues that don’t prevent normal …\nDefines a basic write, append only stream trait to be able …\nAcquire a buffer from the pool.\nPanics\nAdd a parameter to the log entry. paramname_index is the …\nReturns an ascending iterator over the queue’s contents.\nReturns a mutable ascending iterator over the queue’s …\nSize of one buffer\nReturns <code>Some(t)</code> where <code>t</code> is the time <code>self + duration</code> if <code>t</code> …\nReturns the amount of time elapsed from another instant to …\nReturns <code>Some(t)</code> where <code>t</code> is the time <code>self - duration</code> if <code>t</code> …\nClears the queue.\nThe base clock the runtime will be using to record time.\nThis is the main heuristics to compute an execution plan …\nThis module defines the configuration of the copper …\nAdds an edge between two nodes/tasks in the configuration …\nAdds #[copper_runtime(config = “path”, sim_mode = …\nCopperList is the main data structure used by Copper to …\nThe logger for the copper lists (messages between tasks)\nCopy data from a handle to a new handle from the pool.\nTakes a handle to a device buffer and copies it into a …\nCuRuntime is the heart of what copper is running on the …\nThis module contains all the main definition of the traits …\nThis macro is used to log a debug message with parameters. …\nDecrements the time by the given amount. Be careful this …\nConvenience function to returns the default path for the …\nThis is a custom serialization to make this implementation …\nReturns the amount of time elapsed from another instant to …\nReturns the amount of time elapsed since this instant was …\nEnable task logging to the log file.\nReturns true if this log level is enabled for the given …\nIf “something/toto.copper” is given, it will find or …\nText log line formatter.\nThis method is called by the framework when it wants to …\nThis method is called by the framework when it wants to …\nThis method is called by the framework when it wants to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBuilds a monotonic clock starting at the given reference …\nGenerates the CopperList content type from a config. …\nReturns a consistent hashmap of mission names to Graphs …\nReturns the total number of bytes allocated in the current …\nReturns the total number of bytes deallocated in the …\nGet the list of edges that are connected to the given node …\nGet the node with the given id. If mission_id is provided, …\nReturns the original configuration as a string, typically …\nReturns the original configuration as a string, typically …\nGraph structure - either a single graph or multiple …\nA unique and descriptive identifier for the pool.\ndestination is the binary stream in which we will log the …\nthe indices in the copper list of the input messages and …\nInterns a string For example:\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the queue contains no elements.\nReturns <code>true</code> if the queue is full.\nReturns an iterator over the queue’s contents.\nReturns a mutable iterator over the queue’s contents.\nInterval in copperlists between two “keyframes” in the …\nThe logger for the state of the tasks (frozen tasks)\nReturns the current number of elements in the queue.\nFunction called from generated code to log data. It moves …\nThis version of log is only compiled in debug mode This …\nLogger for the copper lists (messages between tasks)\nOptional logging configuration\nThis metadata is the data that is common to all messages.\nRestrict this connection for this list of missions.\nBuild a fake clock with a reference time of 0. The …\nThe runtime monitoring.\nOptional monitoring configuration\nSome basic internal monitoring tooling Copper uses to …\nMessage type exchanged between src and dst.\nCreates a new application.\nCreates a new simulation-enabled application.\nHere you need to initialize everything your task will need …\nHere you need to initialize everything your task will need …\nHere you need to initialize everything your task will need …\nmsg_index is the interned index of the message.\nCreates a RobotClock using now as its reference time. It …\nCreate a new CuHandle not part of a Pool (not for onboard …\nNode: node instance\nNodeId: node id of the task to execute\nGets the current time, scaled to reference time.\nA convenient way to get the current time from the mocking …\nthe index in the copper list of the output message and its …\nPeeks at the last element in the queue.\nGet the list of pools and their statistics. We use …\nThis is a method called by the runtime after “process”…\nThis is a method called by the runtime after “process”…\nThis is a method called by the runtime after “process”…\nThis is a method called by the runtime after “process”…\nThis is a method called by the runtime after “process”…\nThis is a method called by the runtime after “process”…\nThis is a method called by the runtime after “process”…\nThis is a method called by the runtime after “process”…\nThis is a method called by the runtime after “process”…\nThis is a method called by the runtime before “process”…\nThis is a method called by the runtime before “process”…\nThis is a method called by the runtime before “process”…\nThis is a method called by the runtime before “process”…\nThis is a method called by the runtime before “process”…\nThis is a method called by the runtime before “process”…\nThis is a method called by the runtime before “process”…\nThis is a method called by the runtime before “process”…\nThis is a method called by the runtime before “process”…\nProcess is the most critical execution of the task. The …\nProcess is the most critical execution of the task. The …\nProcess is the most critical execution of the task. The …\nCallback that will be trigger at the end of every …\nCallbacked when a Task errored out. The runtime requires …\nThe time range used for the processing of this message\nThe time range used for the processing of this message\nReads the section from the section header pos.\nRead a copper configuration from a file.\nReads all interned strings from the index at the specified …\nRebuild a log line from the interned strings and the …\nGets the most recent current time, scaled to reference …\nAdds a value to the statistics.\nRender the configuration graph in the dot format.\nRestore all tasks from the given frozen state\nRestore all tasks from the given frozen state\nRuns indefinitely looping over run_one_iteration\nRuns indefinitely looping over run_one_iteration in …\nExecutes a single iteration of copper-generated runtime …\nExecutes a single iteration of copper-generated runtime in …\nReturns the amount of time elapsed from another instant to …\nPre-allocated size for each section in the log file.\nSerialize this value into the given Serde serializer.\nThis is a custom serialization to make this implementation …\nSets the absolute value of the time.\n<code>cu29::simulation</code> Module\nSize of each slab in the log file. (it is the size of the …\nNumber of buffer slots left in the pool.\nStart is called between the creation of the task and the …\nStart is called between the creation of the task and the …\nStart is called between the creation of the task and the …\nStart is called between the creation of the task and the …\nStart is called between the creation of the task and the …\nStart is called between the creation of the task and the …\nStart is called between the creation of the task and the …\nStart is called between the creation of the task and the …\nStart is called between the creation of the task and the …\nStarts all tasks managed by the application/runtime.\nStarts all tasks managed by the application/runtime in …\nSmall status text for user UI to get the realtime state of …\nA small string for real time feedback purposes. This is …\nCalled to stop the task. It signals that the *process …\nCalled to stop the task. It signals that the *process …\nCalled to stop the task. It signals that the *process …\nCalled to stop the task. It signals that the *process …\nCalled to stop the task. It signals that the *process …\nCalled to stop the task. It signals that the *process …\nCalled to stop the task. It signals that the *process …\nCalled to stop the task. It signals that the *process …\nCalled to stop the task. It signals that the *process …\nCallbacked when copper is stopping.\nCallbacked when copper is stopping.\nCallbacked when copper is stopping.\nStops all tasks managed by the application/runtime.\nStops all tasks managed by the application/runtime in …\nTells Copper if it needs to log the messages.\nCreate a new stream to write to the unifiedlogger.\nReturns the amount of time elapsed from another instant to …\nCuTaskType: type of the task\nThe tuple of all the tasks in order of execution.\nThis method is called by the framework when it wants to …\nThis method is called by the framework when it wants to …\nThis method is called by the framework when it wants to …\nTotal size of the pool in number of buffers.\nThe time of validity of the message. It can be undefined …\nValidate the logging configuration to ensure section …\nValidate the logging configuration to ensure section …\nGets the current value of time.\nSafely access the inner value, applying a closure to it.\nMutably access the inner value, applying a closure to it.\nA trait that defines the structure and behavior of a …\nA trait that defines the structure and behavior of a …\nThe type representing a simulation step that can be …\nReturns the original configuration as a string, typically …\nReturns the original configuration as a string, typically …\nCreates a new application.\nCreates a new simulation-enabled application.\nRestore all tasks from the given frozen state\nRestore all tasks from the given frozen state\nRuns indefinitely looping over run_one_iteration\nRuns indefinitely looping over run_one_iteration in …\nExecutes a single iteration of copper-generated runtime …\nExecutes a single iteration of copper-generated runtime in …\nStarts all tasks managed by the application/runtime.\nStarts all tasks managed by the application/runtime in …\nStops all tasks managed by the application/runtime.\nStops all tasks managed by the application/runtime in …\nThis represents a connection between 2 tasks (nodes) in …\nThis is the configuration of a component (like a task …\nCuConfig is the programmatic representation of the …\nIncludes are used to include other configuration files.\nMissions are used to generate alternative DAGs within the …\nA node in the configuration graph. A node represents a …\nNodeId is the unique identifier of a node in the …\nWrapper around the ron::Value to allow for custom …\nEnable task logging to the log file.\nGraph structure - either a single graph or multiple …\nInterval in copperlists between two “keyframes” in the …\nOptional logging configuration\nRestrict this connection for this list of missions.\nOptional monitoring configuration\nMessage type exchanged between src and dst.\nRead a copper configuration from a file.\nPre-allocated size for each section in the log file.\nSize of each slab in the log file. (it is the size of the …\nTells Copper if it needs to log the messages.\nNot implemented yet. This mask will be used to for example …\nThose are the possible states along the lifetime of a …\nThis structure maintains the entire memory needed by …\nJust a simple struct to hold the various bits needed to …\nManages the lifecycle of the copper lists and logging.\nThis structure represents a loop in the execution plan. It …\nThis structure represents a step in the execution plan.\nThis structure represents a step in the execution plan.\nThis is the main structure that will be injected as a …\nCopper tasks can be of 3 types:\nA KeyFrame is recording a snapshot of the tasks state …\nManages the frozen tasks state and logging.\nThe base clock the runtime will be using to record time.\nThis is the main heuristics to compute an execution plan …\nThe logger for the copper lists (messages between tasks)\nthe indices in the copper list of the input messages and …\nThe logger for the state of the tasks (frozen tasks)\nLogger for the copper lists (messages between tasks)\nThe runtime monitoring.\nNode: node instance\nNodeId: node id of the task to execute\nthe index in the copper list of the output message and its …\nCuTaskType: type of the task\nThe tuple of all the tasks in order of execution.\nBincode Adapter for Freezable tasks This allows the use of …\nCuMsgMetadata is a structure that contains metadata common …\nA Sink Task is a task that only consumes messages. For …\nA Src Task is a task that only produces messages. For …\nCuMsg is the envelope holding the msg payload and the …\nThis is the most generic Task of copper. It is a “…\nThe internal state of a task needs to be serializable so …\nThis metadata is the data that is common to all messages.\nHere you need to initialize everything your task will need …\nHere you need to initialize everything your task will need …\nHere you need to initialize everything your task will need …\nProcess is the most critical execution of the task. The …\nProcess is the most critical execution of the task. The …\nProcess is the most critical execution of the task. The …\nThe time range used for the processing of this message\nA small string for real time feedback purposes. This is …\nThe time of validity of the message. It can be undefined …\nA simple allocator that counts the number of bytes …\nA Specialized statistics object for CuDuration. It will …\nTrait to implement a monitoring task.\nThe state of a task.\nMonitor decision to be taken when a task errored out.\nAccumulative stat object that can give your some real time …\nA do nothing monitor if no monitor is provided. This is …\nA simple struct that counts the number of bytes allocated …\nCallback that will be trigger at the end of every …\nCallbacked when a Task errored out. The runtime requires …\nCopper friendly wrapper for a fixed size array.\nA Copper-friendly wrapper around ArrayVec with bincode …\nA buffer that is aligned to a specific size with the …\nA shareable handle to an Array coming from a pool (either …\nA Handle to a Buffer. For onboard usages, the buffer …\nA pool of host memory buffers.\nA CuPool is a pool of buffers that can be shared between …\nA device memory pool can copy data from a device to a host …\nBasic Type that can be used in a buffer in a CuPool.\nTrait for a Pool to exposed to be monitored by the …\nAcquire a buffer from the pool.\nSize of one buffer\nCopy data from a handle to a new handle from the pool.\nTakes a handle to a device buffer and copies it into a …\nA unique and descriptive identifier for the pool.\nGet the list of pools and their statistics. We use …\nNumber of buffer slots left in the pool.\nTotal size of the pool in number of buffers.\nThis is a placeholder task for a sink task for the …\nThis is a placeholder task for a source task for the …\nThis is the state that will be passed to the simulation …\nEmulated the behavior of an erroring task (same as return …\nThe actual implementation needs to be executed.\nThe callback took care of the logic on the simulation side …\nCallbacked when a task is created. It gives you the …\nCallbacked when a task is getting called on post-process.\nCallbacked when a task is getting called on pre-process.\nCallbacked when a task is getting called on process. I and …\nThis is the answer the simulator can give to control the …\nCallbacked when a task is started.\nCallbacked when a task is stopped.\nThis is a placeholder task for a sink task for the …\nThis is a placeholder task for a source task for the …\nThis is the state that will be passed to the simulation …\nEmulated the behavior of an erroring task (same as return …\nThe actual implementation needs to be executed.\nThe callback took care of the logic on the simulation side …\nCallbacked when a task is created. It gives you the …\nCallbacked when a task is getting called on post-process.\nCallbacked when a task is getting called on pre-process.\nCallbacked when a task is getting called on process. I and …\nThis is the answer the simulator can give to control the …\nCallbacked when a task is started.\nCallbacked when a task is stopped.")