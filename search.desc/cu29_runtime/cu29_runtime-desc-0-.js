searchState.loadedDescShard("cu29_runtime", 0, "copper GitHub last commit  dependency status License …\nThis module defines the configuration of the copper …\nCopperList is the main data structure used by Copper to …\nCuRuntime is the heart of what copper is running on the …\nThis module contains all the main definition of the traits …\nSome basic internal monitoring tooling Copper uses to …\n<code>cu29::simulation</code> Module\nA trait that defines the structure and behavior of a …\nA trait that defines the structure and behavior of a …\nThe type representing a simulation step that can be …\nReturns the original configuration as a string, typically …\nReturns the original configuration as a string, typically …\nCreates a new application.\nCreates a new simulation-enabled application.\nRestore all tasks from the given frozen state\nRestore all tasks from the given frozen state\nRuns indefinitely looping over run_one_iteration\nRuns indefinitely looping over run_one_iteration in …\nExecutes a single iteration of copper-generated runtime …\nExecutes a single iteration of copper-generated runtime in …\nStarts all tasks managed by the application/runtime.\nStarts all tasks managed by the application/runtime in …\nStops all tasks managed by the application/runtime.\nStops all tasks managed by the application/runtime in …\nThis represents a connection between 2 tasks (nodes) in …\nThis is the configuration of a component (like a task …\nCuConfig is the programmatic representation of the …\nIncludes are used to include other configuration files.\nMissions are used to generate alternative DAGs within the …\nA node in the configuration graph. A node represents a …\nNodeId is the unique identifier of a node in the …\nConfiguration for logging in the node.\nWrapper around the ron::Value to allow for custom …\nAdds an edge between two nodes/tasks in the configuration …\nThis is a custom serialization to make this implementation …\nEnable task logging to the log file.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a consistent hashmap of mission names to Graphs …\nGet the list of edges that are connected to the given node …\nGet the node with the given id. If mission_id is provided, …\nGraph structure - either a single graph or multiple …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInterval in copperlists between two “keyframes” in the …\nOptional logging configuration\nRestrict this connection for this list of missions.\nOptional monitoring configuration\nMessage type exchanged between src and dst.\nRead a copper configuration from a file.\nRender the configuration graph in the dot format.\nPre-allocated size for each section in the log file.\nThis is a custom serialization to make this implementation …\nSize of each slab in the log file. (it is the size of the …\nTells Copper if it needs to log the messages.\nValidate the logging configuration to ensure section …\nValidate the logging configuration to ensure section …\nNot implemented yet. This mask will be used to for example …\nThose are the possible states along the lifetime of a …\nThis structure maintains the entire memory needed by …\nReturns an ascending iterator over the queue’s contents.\nReturns a mutable ascending iterator over the queue’s …\nClears the queue.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the queue contains no elements.\nReturns <code>true</code> if the queue is full.\nReturns an iterator over the queue’s contents.\nReturns a mutable iterator over the queue’s contents.\nReturns the current number of elements in the queue.\nPeeks at the last element in the queue.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nJust a simple struct to hold the various bits needed to …\nManages the lifecycle of the copper lists and logging.\nThis structure represents a loop in the execution plan. It …\nThis structure represents a step in the execution plan.\nThis structure represents a step in the execution plan.\nThis is the main structure that will be injected as a …\nCopper tasks can be of 3 types:\nA KeyFrame is recording a snapshot of the tasks state …\nManages the frozen tasks state and logging.\nThe base clock the runtime will be using to record time.\nThis is the main heuristics to compute an execution plan …\nThe logger for the copper lists (messages between tasks)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nthe indices in the copper list of the input messages and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe logger for the state of the tasks (frozen tasks)\nLogger for the copper lists (messages between tasks)\nThe runtime monitoring.\nNode: node instance\nNodeId: node id of the task to execute\nthe index in the copper list of the output message and its …\nCuTaskType: type of the task\nThe tuple of all the tasks in order of execution.\nFor backgrounded tasks.\nBincode Adapter for Freezable tasks This allows the use of …\nThis is the robotics message type for Copper with the …\nCuMsgMetadata is a structure that contains metadata common …\nA Sink Task is a task that only consumes messages. For …\nA Src Task is a task that only produces messages. For …\nCuMsg is the envelope holding the msg payload and the …\nThis is the most generic Task of copper. It is a “…\nThe internal state of a task needs to be serializable so …\nThis method is called by the framework when it wants to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis metadata is the data that is common to all messages.\nThis metadata is the data that is common to all messages.\nHere you need to initialize everything your task will need …\nHere you need to initialize everything your task will need …\nHere you need to initialize everything your task will need …\nThis is a method called by the runtime after “process”…\nThis is a method called by the runtime after “process”…\nThis is a method called by the runtime after “process”…\nThis is a method called by the runtime before “process”…\nThis is a method called by the runtime before “process”…\nThis is a method called by the runtime before “process”…\nProcess is the most critical execution of the task. The …\nProcess is the most critical execution of the task. The …\nProcess is the most critical execution of the task. The …\nThe time range used for the processing of this message\nStart is called between the creation of the task and the …\nStart is called between the creation of the task and the …\nStart is called between the creation of the task and the …\nA small string for real time feedback purposes. This is …\nCalled to stop the task. It signals that the *process …\nCalled to stop the task. It signals that the *process …\nCalled to stop the task. It signals that the *process …\nThis method is called by the framework when it wants to …\nThe time of validity of the message. It can be undefined …\nThe time of validity of the message. It can be undefined …\nA simple allocator that counts the number of bytes …\nA Specialized statistics object for CuDuration. It will …\nTrait to implement a monitoring task.\nThe state of a task.\nMonitor decision to be taken when a task errored out.\nAccumulative stat object that can give your some real time …\nA do nothing monitor if no monitor is provided. This is …\nA simple struct that counts the number of bytes allocated …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the total number of bytes allocated in the current …\nReturns the total number of bytes deallocated in the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCallback that will be trigger at the end of every …\nCallbacked when a Task errored out. The runtime requires …\nAdds a value to the statistics.\nCallbacked when copper is stopping.\nCopper friendly wrapper for a fixed size array.\nA Copper-friendly wrapper around ArrayVec with bincode …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA buffer that is aligned to a specific size with the …\nA shareable handle to an Array coming from a pool (either …\nA Handle to a Buffer. For onboard usages, the buffer …\nA pool of host memory buffers.\nA CuPool is a pool of buffers that can be shared between …\nA device memory pool can copy data from a device to a host …\nBasic Type that can be used in a buffer in a CuPool.\nTrait for a Pool to exposed to be monitored by the …\nAcquire a buffer from the pool.\nSize of one buffer\nCopy data from a handle to a new handle from the pool.\nTakes a handle to a device buffer and copies it into a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA unique and descriptive identifier for the pool.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new CuHandle not part of a Pool (not for onboard …\nGet the list of pools and their statistics. We use …\nNumber of buffer slots left in the pool.\nTotal size of the pool in number of buffers.\nSafely access the inner value, applying a closure to it.\nMutably access the inner value, applying a closure to it.\nThis is a placeholder task for a sink task for the …\nThis is a placeholder task for a source task for the …\nThis is the state that will be passed to the simulation …\nEmulated the behavior of an erroring task (same as return …\nThe actual implementation needs to be executed.\nThe callback took care of the logic on the simulation side …\nCallbacked when a task is created. It gives you the …\nCallbacked when a task is getting called on post-process.\nCallbacked when a task is getting called on pre-process.\nCallbacked when a task is getting called on process. I and …\nThis is the answer the simulator can give to control the …\nCallbacked when a task is started.\nCallbacked when a task is stopped.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")