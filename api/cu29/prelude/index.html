<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `prelude` mod in crate `cu29`."><title>cu29::prelude - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-77263533.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="cu29" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-nightly (d940e5684 2026-01-19)" data-channel="nightly" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-7bab91a1.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-ffcac47a.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module prelude</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../cu29/index.html">cu29</a><span class="version">0.12.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module prelude</a></h2><h3><a href="#reexports">Module Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#statics" title="Statics">Statics</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li><li><a href="#attributes" title="Attribute Macros">Attribute Macros</a></li><li><a href="#derives" title="Derive Macros">Derive Macros</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate cu29</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">cu29</a></div><h1>Module <span>prelude</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/cu29/lib.rs.html#165">Source</a> </span></div><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.ctrlc"><code>pub use ctrlc;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="app/index.html" title="mod cu29::prelude::app">app</a></dt><dt><a class="mod" href="config/index.html" title="mod cu29::prelude::config">config</a></dt><dd>This module defines the configuration of the copper runtime.
The configuration is a directed graph where nodes are tasks and edges are connections between tasks.
The configuration is serialized in the RON format.
The configuration is used to generate the runtime code at compile time.</dd><dt><a class="mod" href="copperlist/index.html" title="mod cu29::prelude::copperlist">copperlist</a></dt><dd>CopperList is the main data structure used by Copper to communicate between tasks.
It is a queue that can be used to store preallocated messages between tasks in memory order.</dd><dt><a class="mod" href="cuasynctask/index.html" title="mod cu29::prelude::cuasynctask">cuasynctask</a></dt><dt><a class="mod" href="cubridge/index.html" title="mod cu29::prelude::cubridge">cubridge</a></dt><dd>Typed bridge traits and helpers used to connect Copper to external components both as a sink
and a source.</dd><dt><a class="mod" href="curuntime/index.html" title="mod cu29::prelude::curuntime">curuntime</a></dt><dd>CuRuntime is the heart of what copper is running on the robot.
It is exposed to the user via the <code>copper_runtime</code> macro injecting it as a field in their application struct.</dd><dt><a class="mod" href="cutask/index.html" title="mod cu29::prelude::cutask">cutask</a></dt><dd>This module contains all the main definition of the traits you need to implement
or interact with to create a Copper task.</dd><dt><a class="mod" href="memmap/index.html" title="mod cu29::prelude::memmap">memmap</a></dt><dd>This is the memory map file implementation for the unified logger for Copper.
It is std only.</dd><dt><a class="mod" href="monitoring/index.html" title="mod cu29::prelude::monitoring">monitoring</a></dt><dd>Some basic internal monitoring tooling Copper uses to monitor itself and the tasks it is running.</dd><dt><a class="mod" href="payload/index.html" title="mod cu29::prelude::payload">payload</a></dt><dt><a class="mod" href="pool/index.html" title="mod cu29::prelude::pool">pool</a></dt><dt><a class="mod" href="resource/index.html" title="mod cu29::prelude::resource">resource</a></dt><dd>Resource descriptors and utilities to hand resources to tasks and bridges.
User view: in <code>copperconfig.ron</code>, map the binding names your tasks/bridges
expect to the resources exported by your board bundle. Exclusive things
(like a serial port) should be bound once; shared things (like a telemetry
bus <code>Arc</code>) can be bound to multiple consumers.</dd><dt><a class="mod" href="simulation/index.html" title="mod cu29::prelude::simulation">simulation</a></dt><dd><code>cu29::simulation</code> Module</dd></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.__cu29_defmt_debug.html" title="macro cu29::prelude::__cu29_defmt_debug">__<wbr>cu29_<wbr>defmt_<wbr>debug</a></dt><dt><a class="macro" href="macro.__cu29_defmt_error.html" title="macro cu29::prelude::__cu29_defmt_error">__<wbr>cu29_<wbr>defmt_<wbr>error</a></dt><dt><a class="macro" href="macro.__cu29_defmt_info.html" title="macro cu29::prelude::__cu29_defmt_info">__<wbr>cu29_<wbr>defmt_<wbr>info</a></dt><dt><a class="macro" href="macro.__cu29_defmt_warn.html" title="macro cu29::prelude::__cu29_defmt_warn">__<wbr>cu29_<wbr>defmt_<wbr>warn</a></dt><dt><a class="macro" href="macro.__cu29_paste.html" title="macro cu29::prelude::__cu29_paste">__<wbr>cu29_<wbr>paste</a></dt><dt><a class="macro" href="macro.bundle_resources.html" title="macro cu29::prelude::bundle_resources">bundle_<wbr>resources</a></dt><dt><a class="macro" href="macro.critical.html" title="macro cu29::prelude::critical">critical</a></dt><dt><a class="macro" href="macro.debug.html" title="macro cu29::prelude::debug">debug</a></dt><dd>This macro is used to log a debug message with parameters.
The first parameter is a string literal that represents the message to be logged.
Only <code>{}</code> is supported as a placeholder for parameters.
The rest of the parameters are the values to be logged.
The parameters can be named or unnamed.
Named parameters are specified as <code>name = value</code>.
Unnamed parameters are specified as <code>value</code>.</dd><dt><a class="macro" href="macro.defmt_debug.html" title="macro cu29::prelude::defmt_debug">defmt_<wbr>debug</a></dt><dt><a class="macro" href="macro.defmt_error.html" title="macro cu29::prelude::defmt_error">defmt_<wbr>error</a></dt><dt><a class="macro" href="macro.defmt_info.html" title="macro cu29::prelude::defmt_info">defmt_<wbr>info</a></dt><dt><a class="macro" href="macro.defmt_warn.html" title="macro cu29::prelude::defmt_warn">defmt_<wbr>warn</a></dt><dt><a class="macro" href="macro.error.html" title="macro cu29::prelude::error">error</a></dt><dt><a class="macro" href="macro.gen_cumsgs.html" title="macro cu29::prelude::gen_cumsgs">gen_<wbr>cumsgs</a></dt><dd>Generates the CopperList content type from a config.
gen_cumsgs!(“path/to/config.toml”)
It will create a new type called CuStampedDataSet you can pass to the log reader for decoding:</dd><dt><a class="macro" href="macro.info.html" title="macro cu29::prelude::info">info</a></dt><dt><a class="macro" href="macro.input_msg.html" title="macro cu29::prelude::input_msg">input_<wbr>msg</a></dt><dt><a class="macro" href="macro.intern.html" title="macro cu29::prelude::intern">intern</a></dt><dd>Interns a string
For example:</dd><dt><a class="macro" href="macro.output_msg.html" title="macro cu29::prelude::output_msg">output_<wbr>msg</a></dt><dt><a class="macro" href="macro.resources.html" title="macro cu29::prelude::resources">resources</a></dt><dt><a class="macro" href="macro.rx_channels.html" title="macro cu29::prelude::rx_channels">rx_<wbr>channels</a></dt><dd>Declares the receive channels of a <a href="trait.CuBridge.html" title="trait cu29::prelude::CuBridge"><code>CuBridge</code></a> implementation.</dd><dt><a class="macro" href="macro.tx_channels.html" title="macro cu29::prelude::tx_channels">tx_<wbr>channels</a></dt><dd>Declares the transmit channels of a <a href="trait.CuBridge.html" title="trait cu29::prelude::CuBridge"><code>CuBridge</code></a> implementation.</dd><dt><a class="macro" href="macro.warning.html" title="macro cu29::prelude::warning">warning</a></dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AlignedBuffer.html" title="struct cu29::prelude::AlignedBuffer">Aligned<wbr>Buffer</a></dt><dd>A buffer that is aligned to a specific size with the Element of type E.</dd><dt><a class="struct" href="struct.BincodeAdapter.html" title="struct cu29::prelude::BincodeAdapter">Bincode<wbr>Adapter</a></dt><dd>Bincode Adapter for Freezable tasks
This allows the use of the bincode API directly to freeze and thaw tasks.</dd><dt><a class="struct" href="struct.Borrowed.html" title="struct cu29::prelude::Borrowed">Borrowed</a></dt><dd>Wrapper used when a task needs to borrow a resource that remains managed by
the <code>ResourceManager</code>.</dd><dt><a class="struct" href="struct.BridgeChannel.html" title="struct cu29::prelude::BridgeChannel">Bridge<wbr>Channel</a></dt><dd>Compile-time description of a single bridge channel, including the message type carried on it.</dd><dt><a class="struct" href="struct.BridgeChannelConfig.html" title="struct cu29::prelude::BridgeChannelConfig">Bridge<wbr>Channel<wbr>Config</a></dt><dd>Runtime descriptor that includes the parsed per-channel configuration.</dd><dt><a class="struct" href="struct.BridgeChannelDescriptor.html" title="struct cu29::prelude::BridgeChannelDescriptor">Bridge<wbr>Channel<wbr>Descriptor</a></dt><dd>Static metadata describing a channel. Used to pass configuration data at runtime without
leaking the channel’s payload type.</dd><dt><a class="struct" href="struct.BridgeConfig.html" title="struct cu29::prelude::BridgeConfig">Bridge<wbr>Config</a></dt><dd>Declarative definition of a bridge component with a list of channels.</dd><dt><a class="struct" href="struct.BundleContext.html" title="struct cu29::prelude::BundleContext">Bundle<wbr>Context</a></dt><dd>Context passed to bundle providers when building resources.</dd><dt><a class="struct" href="struct.BundleIndex.html" title="struct cu29::prelude::BundleIndex">Bundle<wbr>Index</a></dt><dd>Index identifying a resource bundle in the active mission.</dd><dt><a class="struct" href="struct.Cnx.html" title="struct cu29::prelude::Cnx">Cnx</a></dt><dd>This represents a connection between 2 tasks (nodes) in the configuration graph.</dd><dt><a class="struct" href="struct.ComponentConfig.html" title="struct cu29::prelude::ComponentConfig">Component<wbr>Config</a></dt><dd>This is the configuration of a component (like a task config or a monitoring config):w
It is a map of key-value pairs.
It is given to the new method of the task implementation.</dd><dt><a class="struct" href="struct.ConfigError.html" title="struct cu29::prelude::ConfigError">Config<wbr>Error</a></dt><dt><a class="struct" href="struct.CopperContext.html" title="struct cu29::prelude::CopperContext">Copper<wbr>Context</a></dt><dd>Just a simple struct to hold the various bits needed to run a Copper application.</dd><dt><a class="struct" href="struct.CopperLiskMask.html" title="struct cu29::prelude::CopperLiskMask">Copper<wbr>Lisk<wbr>Mask</a></dt><dd>Not implemented yet.
This mask will be used to for example filter out necessary regions of a copper list between remote systems.</dd><dt><a class="struct" href="struct.CopperList.html" title="struct cu29::prelude::CopperList">Copper<wbr>List</a></dt><dt><a class="struct" href="struct.CopperListInfo.html" title="struct cu29::prelude::CopperListInfo">Copper<wbr>List<wbr>Info</a></dt><dt><a class="struct" href="struct.CopperListIoStats.html" title="struct cu29::prelude::CopperListIoStats">Copper<wbr>List<wbr>IoStats</a></dt><dd>Reported data about CopperList IO for a single iteration.</dd><dt><a class="struct" href="struct.CopperListsManager.html" title="struct cu29::prelude::CopperListsManager">Copper<wbr>Lists<wbr>Manager</a></dt><dd>Manages the lifecycle of the copper lists and logging.</dd><dt><a class="struct" href="struct.CountingAlloc.html" title="struct cu29::prelude::CountingAlloc">Counting<wbr>Alloc</a></dt><dd>A simple allocator that counts the number of bytes allocated and deallocated.</dd><dt><a class="struct" href="struct.CuArray.html" title="struct cu29::prelude::CuArray">CuArray</a></dt><dd>Copper friendly wrapper for a fixed size array.</dd><dt><a class="struct" href="struct.CuArrayVec.html" title="struct cu29::prelude::CuArrayVec">CuArray<wbr>Vec</a></dt><dd>A Copper-friendly wrapper around ArrayVec with bincode serialization support.</dd><dt><a class="struct" href="struct.CuCompactString.html" title="struct cu29::prelude::CuCompactString">CuCompact<wbr>String</a></dt><dt><a class="struct" href="struct.CuConfig.html" title="struct cu29::prelude::CuConfig">CuConfig</a></dt><dd>CuConfig is the programmatic representation of the configuration graph.
It is a directed graph where nodes are tasks and edges are connections between tasks.</dd><dt><a class="struct" href="struct.CuDuration.html" title="struct cu29::prelude::CuDuration">CuDuration</a></dt><dd>For Robot times, the underlying type is a u64 representing nanoseconds.
It is always positive to simplify the reasoning on the user side.</dd><dt><a class="struct" href="struct.CuDurationStatistics.html" title="struct cu29::prelude::CuDurationStatistics">CuDuration<wbr>Statistics</a></dt><dd>A Specialized statistics object for CuDuration.
It will also keep track of the jitter between the values.</dd><dt><a class="struct" href="struct.CuError.html" title="struct cu29::prelude::CuError">CuError</a></dt><dd>Common copper Error type.</dd><dt><a class="struct" href="struct.CuExecutionLoop.html" title="struct cu29::prelude::CuExecutionLoop">CuExecution<wbr>Loop</a></dt><dd>This structure represents a loop in the execution plan.
It is used to represent a sequence of Execution units (loop or steps) that are executed
multiple times.
if loop_count is None, the loop is infinite.</dd><dt><a class="struct" href="struct.CuExecutionStep.html" title="struct cu29::prelude::CuExecutionStep">CuExecution<wbr>Step</a></dt><dd>This structure represents a step in the execution plan.</dd><dt><a class="struct" href="struct.CuGraph.html" title="struct cu29::prelude::CuGraph">CuGraph</a></dt><dt><a class="struct" href="struct.CuHandle.html" title="struct cu29::prelude::CuHandle">CuHandle</a></dt><dd>A shareable handle to an Array coming from a pool (either host or device).</dd><dt><a class="struct" href="struct.CuHostMemoryPool.html" title="struct cu29::prelude::CuHostMemoryPool">CuHost<wbr>Memory<wbr>Pool</a></dt><dd>A pool of host memory buffers.</dd><dt><a class="struct" href="struct.CuInputMsg.html" title="struct cu29::prelude::CuInputMsg">CuInput<wbr>Msg</a></dt><dt><a class="struct" href="struct.CuInstant.html" title="struct cu29::prelude::CuInstant">CuInstant</a></dt><dd>High-precision instant in time, represented as nanoseconds since an arbitrary epoch</dd><dt><a class="struct" href="struct.CuListsManager.html" title="struct cu29::prelude::CuListsManager">CuLists<wbr>Manager</a></dt><dd>This structure maintains the entire memory needed by Copper for one loop for the inter tasks communication within a process.
P or Payload is typically a Tuple of various types of messages that are exchanged between tasks.
N is the maximum number of in flight Copper List the runtime can support.</dd><dt><a class="struct" href="struct.CuLogEntry.html" title="struct cu29::prelude::CuLogEntry">CuLog<wbr>Entry</a></dt><dd>This is the basic structure for a log entry in Copper.</dd><dt><a class="struct" href="struct.CuMsgMetadata.html" title="struct cu29::prelude::CuMsgMetadata">CuMsg<wbr>Metadata</a></dt><dd>CuMsgMetadata is a structure that contains metadata common to all CuStampedDataSet.</dd><dt><a class="struct" href="struct.CuOutputPack.html" title="struct cu29::prelude::CuOutputPack">CuOutput<wbr>Pack</a></dt><dt><a class="struct" href="struct.CuRuntime.html" title="struct cu29::prelude::CuRuntime">CuRuntime</a></dt><dd>This is the main structure that will be injected as a member of the Application struct.
CT is the tuple of all the tasks in order of execution.
CL is the type of the copper list, representing the input/output messages for all the tasks.</dd><dt><a class="struct" href="struct.CuSimSinkTask.html" title="struct cu29::prelude::CuSimSinkTask">CuSim<wbr>Sink<wbr>Task</a></dt><dd>This is a placeholder task for a sink task for the simulations.
It basically does nothing in place of a real driver so it won’t try to initialize any hardware.</dd><dt><a class="struct" href="struct.CuSimSrcTask.html" title="struct cu29::prelude::CuSimSrcTask">CuSim<wbr>SrcTask</a></dt><dd>This is a placeholder task for a source task for the simulations.
It basically does nothing in place of a real driver so it won’t try to initialize any hardware.</dd><dt><a class="struct" href="struct.CuStampedData.html" title="struct cu29::prelude::CuStampedData">CuStamped<wbr>Data</a></dt><dd>CuMsg is the envelope holding the msg payload and the metadata between tasks.</dd><dt><a class="struct" href="struct.CuTimeRange.html" title="struct cu29::prelude::CuTimeRange">CuTime<wbr>Range</a></dt><dd>Represents a time range.</dd><dt><a class="struct" href="struct.EndOfLogMarker.html" title="struct cu29::prelude::EndOfLogMarker">EndOf<wbr>LogMarker</a></dt><dd>Payload stored in the end-of-log section to signal whether the log was cleanly closed.</dd><dt><a class="struct" href="struct.IncludesConfig.html" title="struct cu29::prelude::IncludesConfig">Includes<wbr>Config</a></dt><dd>Includes are used to include other configuration files.</dd><dt><a class="struct" href="struct.KeyFrame.html" title="struct cu29::prelude::KeyFrame">KeyFrame</a></dt><dd>A KeyFrame is recording a snapshot of the tasks state before a given copperlist.
It is a double encapsulation: this one recording the culistid and another even in
bincode in the serialized_tasks.</dd><dt><a class="struct" href="struct.KeyFramesManager.html" title="struct cu29::prelude::KeyFramesManager">KeyFrames<wbr>Manager</a></dt><dd>Manages the frozen tasks state and logging.</dd><dt><a class="struct" href="struct.LiveStatistics.html" title="struct cu29::prelude::LiveStatistics">Live<wbr>Statistics</a></dt><dd>Accumulative stat object that can give your some real time statistics.
Uses a fixed-size bucketed histogram for accurate percentile calculations.</dd><dt><a class="struct" href="struct.LogStream.html" title="struct cu29::prelude::LogStream">LogStream</a></dt><dd>A wrapper around the unifiedlogger that implements the Write trait.</dd><dt><a class="struct" href="struct.LoggerRuntime.html" title="struct cu29::prelude::LoggerRuntime">Logger<wbr>Runtime</a></dt><dd>The lifetime of this struct is the lifetime of the logger.</dd><dt><a class="struct" href="struct.LoggingConfig.html" title="struct cu29::prelude::LoggingConfig">Logging<wbr>Config</a></dt><dt><a class="struct" href="struct.MainHeader.html" title="struct cu29::prelude::MainHeader">Main<wbr>Header</a></dt><dd>The main file header of the datalogger.</dd><dt><a class="struct" href="struct.MissionsConfig.html" title="struct cu29::prelude::MissionsConfig">Missions<wbr>Config</a></dt><dd>Missions are used to generate alternative DAGs within the same configuration.</dd><dt><a class="struct" href="struct.MonitorConfig.html" title="struct cu29::prelude::MonitorConfig">Monitor<wbr>Config</a></dt><dt><a class="struct" href="struct.MonitorConnection.html" title="struct cu29::prelude::MonitorConnection">Monitor<wbr>Connection</a></dt><dt><a class="struct" href="struct.MonitorNode.html" title="struct cu29::prelude::MonitorNode">Monitor<wbr>Node</a></dt><dt><a class="struct" href="struct.MonitorTopology.html" title="struct cu29::prelude::MonitorTopology">Monitor<wbr>Topology</a></dt><dt><a class="struct" href="struct.NoMonitor.html" title="struct cu29::prelude::NoMonitor">NoMonitor</a></dt><dd>A do nothing monitor if no monitor is provided.
This is basically defining the default behavior of Copper in case of error.</dd><dt><a class="struct" href="struct.Node.html" title="struct cu29::prelude::Node">Node</a></dt><dd>A node in the configuration graph.
A node represents a Task in the system Graph.</dd><dt><a class="struct" href="struct.NodeLogging.html" title="struct cu29::prelude::NodeLogging">Node<wbr>Logging</a></dt><dd>Configuration for logging in the node.</dd><dt><a class="struct" href="struct.NullLog.html" title="struct cu29::prelude::NullLog">NullLog</a></dt><dt><a class="struct" href="struct.OptionCuTime.html" title="struct cu29::prelude::OptionCuTime">Option<wbr>CuTime</a></dt><dd>Homebrewed <code>Option&lt;CuDuration&gt;</code> to avoid using 128bits just to represent an Option.</dd><dt><a class="struct" href="struct.Owned.html" title="struct cu29::prelude::Owned">Owned</a></dt><dd>Lightweight wrapper used when a task needs to take ownership of a resource.</dd><dt><a class="struct" href="struct.OwningIoWriter.html" title="struct cu29::prelude::OwningIoWriter">Owning<wbr>IoWriter</a></dt><dt><a class="struct" href="struct.PartialCuTimeRange.html" title="struct cu29::prelude::PartialCuTimeRange">Partial<wbr>CuTime<wbr>Range</a></dt><dd>Represents a time range with possible undefined start or end or both.</dd><dt><a class="struct" href="struct.ResourceBindingMap.html" title="struct cu29::prelude::ResourceBindingMap">Resource<wbr>Binding<wbr>Map</a></dt><dd>Static mapping between user-defined binding ids and resource keys.</dd><dt><a class="struct" href="struct.ResourceBundleConfig.html" title="struct cu29::prelude::ResourceBundleConfig">Resource<wbr>Bundle<wbr>Config</a></dt><dd>Declarative definition of a resource bundle.</dd><dt><a class="struct" href="struct.ResourceKey.html" title="struct cu29::prelude::ResourceKey">Resource<wbr>Key</a></dt><dd>Typed identifier for a resource entry.</dd><dt><a class="struct" href="struct.ResourceManager.html" title="struct cu29::prelude::ResourceManager">Resource<wbr>Manager</a></dt><dd>Manages the concrete resources available to tasks and bridges.</dd><dt><a class="struct" href="struct.RobotClock.html" title="struct cu29::prelude::RobotClock">Robot<wbr>Clock</a></dt><dd>A running Robot clock.
The clock is a monotonic clock that starts at an arbitrary reference time.
It is clone resilient, ie a clone will be the same clock, even when mocked.</dd><dt><a class="struct" href="struct.RobotClockMock.html" title="struct cu29::prelude::RobotClockMock">Robot<wbr>Clock<wbr>Mock</a></dt><dd>A mock clock that can be controlled by the user.</dd><dt><a class="struct" href="struct.RuntimeConfig.html" title="struct cu29::prelude::RuntimeConfig">Runtime<wbr>Config</a></dt><dt><a class="struct" href="struct.SectionHandle.html" title="struct cu29::prelude::SectionHandle">Section<wbr>Handle</a></dt><dd>A SectionHandle is a handle to a section in the datalogger.
It allows tracking the lifecycle of the section.</dd><dt><a class="struct" href="struct.SectionHeader.html" title="struct cu29::prelude::SectionHeader">Section<wbr>Header</a></dt><dd>Each concurrent sublogger is tracked through a section header.
They form a linked list of sections.
The entry type is used to identify the type of data in the section.</dd><dt><a class="struct" href="struct.SimpleFileWriter.html" title="struct cu29::prelude::SimpleFileWriter">Simple<wbr>File<wbr>Writer</a></dt><dd>This allows this crate to be used outside of Copper (ie. decoupling it from the unifiedlog.</dd><dt><a class="struct" href="struct.ThreadPoolBundle.html" title="struct cu29::prelude::ThreadPoolBundle">Thread<wbr>Pool<wbr>Bundle</a></dt><dt><a class="struct" href="struct.UnifiedLogStatus.html" title="struct cu29::prelude::UnifiedLogStatus">Unified<wbr>LogStatus</a></dt><dd>Basic statistics for the unified logger.
Note: the total_allocated_space might grow for the std implementation</dd><dt><a class="struct" href="struct.UnifiedLoggerBuilder.html" title="struct cu29::prelude::UnifiedLoggerBuilder">Unified<wbr>Logger<wbr>Builder</a></dt><dd>Use this builder to create a new DataLogger.</dd><dt><a class="struct" href="struct.UnifiedLoggerIOReader.html" title="struct cu29::prelude::UnifiedLoggerIOReader">Unified<wbr>LoggerIO<wbr>Reader</a></dt><dd>This a convenience wrapper around the UnifiedLoggerRead to implement the Read trait.</dd><dt><a class="struct" href="struct.UnifiedLoggerRead.html" title="struct cu29::prelude::UnifiedLoggerRead">Unified<wbr>Logger<wbr>Read</a></dt><dd>A read side of the memory map based unified logger.</dd><dt><a class="struct" href="struct.UnifiedLoggerWrite.html" title="struct cu29::prelude::UnifiedLoggerWrite">Unified<wbr>Logger<wbr>Write</a></dt><dd>A write side of the datalogger.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.AllocatedSection.html" title="enum cu29::prelude::AllocatedSection">Allocated<wbr>Section</a></dt><dt><a class="enum" href="enum.BridgeChannelConfigRepresentation.html" title="enum cu29::prelude::BridgeChannelConfigRepresentation">Bridge<wbr>Channel<wbr>Config<wbr>Representation</a></dt><dd>Directional mapping for bridge channels.</dd><dt><a class="enum" href="enum.ComponentKind.html" title="enum cu29::prelude::ComponentKind">Component<wbr>Kind</a></dt><dt><a class="enum" href="enum.ConfigGraphs.html" title="enum cu29::prelude::ConfigGraphs">Config<wbr>Graphs</a></dt><dt><a class="enum" href="enum.CopperListState.html" title="enum cu29::prelude::CopperListState">Copper<wbr>List<wbr>State</a></dt><dd>Those are the possible states along the lifetime of a CopperList.</dd><dt><a class="enum" href="enum.CuDirection.html" title="enum cu29::prelude::CuDirection">CuDirection</a></dt><dd>A simple wrapper enum for <code>petgraph::Direction</code>,
designed to be converted <em>into</em> it via the <code>From</code> trait.</dd><dt><a class="enum" href="enum.CuExecutionUnit.html" title="enum cu29::prelude::CuExecutionUnit">CuExecution<wbr>Unit</a></dt><dd>This structure represents a step in the execution plan.</dd><dt><a class="enum" href="enum.CuHandleInner.html" title="enum cu29::prelude::CuHandleInner">CuHandle<wbr>Inner</a></dt><dd>A Handle to a Buffer.
For onboard usages, the buffer should be Pooled (ie, coming from a preallocated pool).
The Detached version is for offline usages where we don’t really need a pool to deserialize them.</dd><dt><a class="enum" href="enum.CuLogLevel.html" title="enum cu29::prelude::CuLogLevel">CuLog<wbr>Level</a></dt><dd>Log levels for Copper.</dd><dt><a class="enum" href="enum.CuTaskCallbackState.html" title="enum cu29::prelude::CuTaskCallbackState">CuTask<wbr>Callback<wbr>State</a></dt><dd>This is the state that will be passed to the simulation support to hook
into the lifecycle of the tasks.</dd><dt><a class="enum" href="enum.CuTaskState.html" title="enum cu29::prelude::CuTaskState">CuTask<wbr>State</a></dt><dd>The state of a task.</dd><dt><a class="enum" href="enum.CuTaskType.html" title="enum cu29::prelude::CuTaskType">CuTask<wbr>Type</a></dt><dd>Copper tasks can be of 3 types:</dd><dt><a class="enum" href="enum.Decision.html" title="enum cu29::prelude::Decision">Decision</a></dt><dd>Monitor decision to be taken when a task errored out.</dd><dt><a class="enum" href="enum.Flavor.html" title="enum cu29::prelude::Flavor">Flavor</a></dt><dd>Distinguishes regular tasks from bridge nodes so downstream stages can apply
bridge-specific instantiation rules.</dd><dt><a class="enum" href="enum.SimOverride.html" title="enum cu29::prelude::SimOverride">SimOverride</a></dt><dd>This is the answer the simulator can give to control the simulation flow.</dd><dt><a class="enum" href="enum.ThreadPoolId.html" title="enum cu29::prelude::ThreadPoolId">Thread<wbr>Pool<wbr>Id</a></dt><dt><a class="enum" href="enum.Tov.html" title="enum cu29::prelude::Tov">Tov</a></dt><dd>The time of validity of a message can be more than one time but can be a time range of Tovs.
For example a sub scan for a lidar, a set of images etc… can have a range of validity.</dd><dt><a class="enum" href="enum.UnifiedLogType.html" title="enum cu29::prelude::UnifiedLogType">Unified<wbr>LogType</a></dt><dd>Defines the types of what can be logged in the unified logger.</dd><dt><a class="enum" href="enum.UnifiedLogger.html" title="enum cu29::prelude::UnifiedLogger">Unified<wbr>Logger</a></dt><dd>Holds the read or write side of the datalogger.</dd><dt><a class="enum" href="enum.Value.html" title="enum cu29::prelude::Value">Value</a></dt></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.ANONYMOUS.html" title="constant cu29::prelude::ANONYMOUS">ANONYMOUS</a></dt><dt><a class="constant" href="constant.COMPACT_STRING_CAPACITY.html" title="constant cu29::prelude::COMPACT_STRING_CAPACITY">COMPACT_<wbr>STRING_<wbr>CAPACITY</a></dt><dt><a class="constant" href="constant.DEFAULT_KEYFRAME_INTERVAL.html" title="constant cu29::prelude::DEFAULT_KEYFRAME_INTERVAL">DEFAULT_<wbr>KEYFRAME_<wbr>INTERVAL</a></dt><dt><a class="constant" href="constant.MAIN_MAGIC.html" title="constant cu29::prelude::MAIN_MAGIC">MAIN_<wbr>MAGIC</a></dt><dd>ID to spot the beginning of a Copper Log</dd><dt><a class="constant" href="constant.MAX_LOG_PARAMS_ON_STACK.html" title="constant cu29::prelude::MAX_LOG_PARAMS_ON_STACK">MAX_<wbr>LOG_<wbr>PARAMS_<wbr>ON_<wbr>STACK</a></dt><dt><a class="constant" href="constant.SECTION_HEADER_COMPACT_SIZE.html" title="constant cu29::prelude::SECTION_HEADER_COMPACT_SIZE">SECTION_<wbr>HEADER_<wbr>COMPACT_<wbr>SIZE</a></dt><dt><a class="constant" href="constant.SECTION_MAGIC.html" title="constant cu29::prelude::SECTION_MAGIC">SECTION_<wbr>MAGIC</a></dt><dd>ID to spot a section of Copper Log</dd></dl><h2 id="statics" class="section-header">Statics<a href="#statics" class="anchor">§</a></h2><dl class="item-table"><dt><a class="static" href="static.EXTRA_TEXT_LOGGER.html" title="static cu29::prelude::EXTRA_TEXT_LOGGER">EXTRA_<wbr>TEXT_<wbr>LOGGER</a></dt></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.ArrayLike.html" title="trait cu29::prelude::ArrayLike">Array<wbr>Like</a></dt><dt><a class="trait" href="trait.BridgeChannelInfo.html" title="trait cu29::prelude::BridgeChannelInfo">Bridge<wbr>Channel<wbr>Info</a></dt><dd>Type-erased metadata exposed for channel enumeration and configuration.</dd><dt><a class="trait" href="trait.BridgeChannelSet.html" title="trait cu29::prelude::BridgeChannelSet">Bridge<wbr>Channel<wbr>Set</a></dt><dd>Describes a set of channels for one direction (Tx or Rx) of the bridge.</dd><dt><a class="trait" href="trait.ClockProvider.html" title="trait cu29::prelude::ClockProvider">Clock<wbr>Provider</a></dt><dd>A trait to provide a clock to the runtime.</dd><dt><a class="trait" href="trait.CopperListTuple.html" title="trait cu29::prelude::CopperListTuple">Copper<wbr>List<wbr>Tuple</a></dt><dd>A CopperListTuple needs to be encodable, decodable and fixed size in memory.</dd><dt><a class="trait" href="trait.CuApplication.html" title="trait cu29::prelude::CuApplication">CuApplication</a></dt><dd>A trait that defines the structure and behavior of a CuApplication.</dd><dt><a class="trait" href="trait.CuBridge.html" title="trait cu29::prelude::CuBridge">CuBridge</a></dt><dd>Public trait implemented by every copper bridge.</dd><dt><a class="trait" href="trait.CuListZeroedInit.html" title="trait cu29::prelude::CuListZeroedInit">CuList<wbr>Zeroed<wbr>Init</a></dt><dd>Initializes fields that cannot be zeroed after allocating a zeroed
<a href="struct.CopperList.html" title="struct cu29::prelude::CopperList"><code>CopperList</code></a>.</dd><dt><a class="trait" href="trait.CuMonitor.html" title="trait cu29::prelude::CuMonitor">CuMonitor</a></dt><dd>Trait to implement a monitoring task.</dd><dt><a class="trait" href="trait.CuMsgMetadataTrait.html" title="trait cu29::prelude::CuMsgMetadataTrait">CuMsg<wbr>Metadata<wbr>Trait</a></dt><dd>Key metadata piece attached to every message in Copper.</dd><dt><a class="trait" href="trait.CuMsgPack.html" title="trait cu29::prelude::CuMsgPack">CuMsg<wbr>Pack</a></dt><dt><a class="trait" href="trait.CuMsgPayload.html" title="trait cu29::prelude::CuMsgPayload">CuMsg<wbr>Payload</a></dt><dd>The state of a task.</dd><dt><a class="trait" href="trait.CuPayloadSize.html" title="trait cu29::prelude::CuPayloadSize">CuPayload<wbr>Size</a></dt><dd>Lightweight trait to estimate the amount of data a payload will contribute when serialized.
Default implementations return the stack size; specific types override to report dynamic data.</dd><dt><a class="trait" href="trait.CuPool.html" title="trait cu29::prelude::CuPool">CuPool</a></dt><dd>A CuPool is a pool of buffers that can be shared between different parts of the code.
Handles can be stored locally in the tasks and shared between them.</dd><dt><a class="trait" href="trait.CuSimApplication.html" title="trait cu29::prelude::CuSimApplication">CuSim<wbr>Application</a></dt><dd>A trait that defines the structure and behavior of a simulation-enabled CuApplication.</dd><dt><a class="trait" href="trait.CuSimSinkInput.html" title="trait cu29::prelude::CuSimSinkInput">CuSim<wbr>Sink<wbr>Input</a></dt><dd>Helper to map a payload type (or tuple of payload types) to the corresponding <code>input_msg!</code> form.</dd><dt><a class="trait" href="trait.CuSinkTask.html" title="trait cu29::prelude::CuSinkTask">CuSink<wbr>Task</a></dt><dd>A Sink Task is a task that only consumes messages. For example drivers for actuators are Sink Tasks.</dd><dt><a class="trait" href="trait.CuSrcTask.html" title="trait cu29::prelude::CuSrcTask">CuSrc<wbr>Task</a></dt><dd>A Src Task is a task that only produces messages. For example drivers for sensors are Src Tasks.
They are in push mode from the runtime.
To set the frequency of the pulls and align them to any hw, see the runtime configuration.
Note: A source has the privilege to have a clock passed to it vs a frozen clock.</dd><dt><a class="trait" href="trait.CuStdApplication.html" title="trait cu29::prelude::CuStdApplication">CuStd<wbr>Application</a></dt><dd>Convenience trait for CuApplication when it is just a std App</dd><dt><a class="trait" href="trait.CuTask.html" title="trait cu29::prelude::CuTask">CuTask</a></dt><dd>This is the most generic Task of copper. It is a “transform” task deriving an output from an input.</dd><dt><a class="trait" href="trait.DeviceCuPool.html" title="trait cu29::prelude::DeviceCuPool">Device<wbr>CuPool</a></dt><dd>A device memory pool can copy data from a device to a host memory pool on top.</dd><dt><a class="trait" href="trait.ElementType.html" title="trait cu29::prelude::ElementType">Element<wbr>Type</a></dt><dd>Basic Type that can be used in a buffer in a CuPool.</dd><dt><a class="trait" href="trait.ErasedCuStampedData.html" title="trait cu29::prelude::ErasedCuStampedData">Erased<wbr>CuStamped<wbr>Data</a></dt><dd>A generic trait to expose the generated CuStampedDataSet from the task graph.</dd><dt><a class="trait" href="trait.ErasedCuStampedDataSet.html" title="trait cu29::prelude::ErasedCuStampedDataSet">Erased<wbr>CuStamped<wbr>Data<wbr>Set</a></dt><dd>Trait to get a vector of type-erased CuStampedDataSet
This is used for generic serialization of the copperlists</dd><dt><a class="trait" href="trait.Freezable.html" title="trait cu29::prelude::Freezable">Freezable</a></dt><dd>The internal state of a task needs to be serializable
so the framework can take a snapshot of the task graph.</dd><dt><a class="trait" href="trait.MatchingTasks.html" title="trait cu29::prelude::MatchingTasks">Matching<wbr>Tasks</a></dt><dd>Trait to trace back from the CopperList the origin of the messages</dd><dt><a class="trait" href="trait.Metadata.html" title="trait cu29::prelude::Metadata">Metadata</a></dt><dd>Represent the minimum set of traits to be usable as Metadata in Copper.</dd><dt><a class="trait" href="trait.PayloadSchemas.html" title="trait cu29::prelude::PayloadSchemas">Payload<wbr>Schemas</a></dt><dd>Trait for providing JSON schemas for CopperList payload types.</dd><dt><a class="trait" href="trait.PoolMonitor.html" title="trait cu29::prelude::PoolMonitor">Pool<wbr>Monitor</a></dt><dd>Trait for a Pool to exposed to be monitored by the monitoring API.</dd><dt><a class="trait" href="trait.ResourceBindings.html" title="trait cu29::prelude::ResourceBindings">Resource<wbr>Bindings</a></dt><dd>Trait implemented by resource binding structs passed to task/bridge
constructors. Implementors pull the concrete resources they need from the
<code>ResourceManager</code>, using the symbolic mapping provided in the Copper config
(<code>resources: { name: "bundle.resource" }</code>).</dd><dt><a class="trait" href="trait.ResourceBundle.html" title="trait cu29::prelude::ResourceBundle">Resource<wbr>Bundle</a></dt><dd>Bundle providers implement this trait to populate the <code>ResourceManager</code> with
concrete resources for a given bundle id.</dd><dt><a class="trait" href="trait.ResourceBundleDecl.html" title="trait cu29::prelude::ResourceBundleDecl">Resource<wbr>Bundle<wbr>Decl</a></dt><dd>Trait implemented by bundle providers to declare their resource id enum.</dd><dt><a class="trait" href="trait.ResourceId.html" title="trait cu29::prelude::ResourceId">Resource<wbr>Id</a></dt><dd>Trait implemented by resource id enums generated by <code>bundle_resources!</code>.</dd><dt><a class="trait" href="trait.SaturatingSub.html" title="trait cu29::prelude::SaturatingSub">Saturating<wbr>Sub</a></dt><dd>Saturating subtraction for time and duration types.</dd><dt><a class="trait" href="trait.SectionStorage.html" title="trait cu29::prelude::SectionStorage">Section<wbr>Storage</a></dt><dd>A Storage is an append-only structure that can update a header section.</dd><dt><a class="trait" href="trait.Serialize.html" title="trait cu29::prelude::Serialize">Serialize</a></dt><dd>A <strong>data structure</strong> that can be serialized into any data format supported
by Serde.</dd><dt><a class="trait" href="trait.UnifiedLogRead.html" title="trait cu29::prelude::UnifiedLogRead">Unified<wbr>LogRead</a></dt><dd>Read back a unified log linearly.</dd><dt><a class="trait" href="trait.UnifiedLogWrite.html" title="trait cu29::prelude::UnifiedLogWrite">Unified<wbr>LogWrite</a></dt><dd>The writing interface to the unified logger.
Writing is “almost” linear as various streams can allocate sections and track them until
they drop them.</dd><dt><a class="trait" href="trait.WriteStream.html" title="trait cu29::prelude::WriteStream">Write<wbr>Stream</a></dt><dd>Defines a basic write, append only stream trait to be able to log or send serializable objects.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.build_monitor_topology.html" title="fn cu29::prelude::build_monitor_topology">build_<wbr>monitor_<wbr>topology</a></dt><dd>Derive a monitor-friendly topology from the runtime configuration.</dd><dt><a class="fn" href="fn.busy_wait_for.html" title="fn cu29::prelude::busy_wait_for">busy_<wbr>wait_<wbr>for</a></dt><dd>A busy looping function based on this clock for a duration.
Mainly useful for embedded to spinlocking.</dd><dt><a class="fn" href="fn.busy_wait_until.html" title="fn cu29::prelude::busy_wait_until">busy_<wbr>wait_<wbr>until</a></dt><dd>A busy looping function based on this until a specific time.
Mainly useful for embedded to spinlocking.</dd><dt><a class="fn" href="fn.compute_runtime_plan.html" title="fn cu29::prelude::compute_runtime_plan">compute_<wbr>runtime_<wbr>plan</a></dt><dd>This is the main heuristics to compute an execution plan at compilation time.
TODO(gbin): Make that heuristic pluggable.</dd><dt><a class="fn" href="fn.find_task_type_for_id.html" title="fn cu29::prelude::find_task_type_for_id">find_<wbr>task_<wbr>type_<wbr>for_<wbr>id</a></dt><dt><a class="fn" href="fn.format_logline.html" title="fn cu29::prelude::format_logline">format_<wbr>logline</a></dt><dd>Text log line formatter.
Only available on std. TODO(gbin): Maybe reconsider that at some point</dd><dt><a class="fn" href="fn.initialize.html" title="fn cu29::prelude::initialize">initialize</a></dt><dt><a class="fn" href="fn.log.html" title="fn cu29::prelude::log">log</a></dt><dd>Function called from generated code to log data.
It moves entry by design, it will be absorbed in the queue.</dd><dt><a class="fn" href="fn.log_debug_mode.html" title="fn cu29::prelude::log_debug_mode">log_<wbr>debug_<wbr>mode</a></dt><dd>This version of log is only compiled in debug mode
This allows a normal logging framework to be bridged.</dd><dt><a class="fn" href="fn.pools_statistics.html" title="fn cu29::prelude::pools_statistics">pools_<wbr>statistics</a></dt><dd>Get the list of pools and their statistics.
We use SmallVec here to avoid heap allocations while the stack is running.</dd><dt><a class="fn" href="fn.read_configuration.html" title="fn cu29::prelude::read_configuration">read_<wbr>configuration</a></dt><dd>Read a copper configuration from a file.</dd><dt><a class="fn" href="fn.read_configuration_str.html" title="fn cu29::prelude::read_configuration_str">read_<wbr>configuration_<wbr>str</a></dt><dt><a class="fn" href="fn.read_raw_counter.html" title="fn cu29::prelude::read_raw_counter">read_<wbr>raw_<wbr>counter</a></dt><dt><a class="fn" href="fn.rebuild_logline.html" title="fn cu29::prelude::rebuild_logline">rebuild_<wbr>logline</a></dt><dd>Rebuild a log line from the interned strings and the CuLogEntry.
This basically translates the world of copper logs to text logs.</dd><dt><a class="fn" href="fn.stream_write.html" title="fn cu29::prelude::stream_write">stream_<wbr>write</a></dt><dd>Create a new stream to write to the unifiedlogger.</dd><dt><a class="fn" href="fn.structured_log_bytes_total.html" title="fn cu29::prelude::structured_log_bytes_total">structured_<wbr>log_<wbr>bytes_<wbr>total</a></dt><dd>Returns the total number of bytes written to the structured log stream.</dd><dt><a class="fn" href="fn.to_value.html" title="fn cu29::prelude::to_value">to_<wbr>value</a></dt><dt><a class="fn" href="fn.with_cause.html" title="fn cu29::prelude::with_cause">with_<wbr>cause</a></dt><dd>Creates a CuError with a message and cause in a single call.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.AscIter.html" title="type cu29::prelude::AscIter">AscIter</a></dt><dt><a class="type" href="type.AscIterMut.html" title="type cu29::prelude::AscIterMut">AscIter<wbr>Mut</a></dt><dt><a class="type" href="type.CuMsg.html" title="type cu29::prelude::CuMsg">CuMsg</a></dt><dd>This is the robotics message type for Copper with the correct Metadata type
that will be used by the runtime.</dd><dt><a class="type" href="type.CuResult.html" title="type cu29::prelude::CuResult">CuResult</a></dt><dt><a class="type" href="type.CuTime.html" title="type cu29::prelude::CuTime">CuTime</a></dt><dd>A robot time is just a duration from a fixed point in time.</dd><dt><a class="type" href="type.Instant.html" title="type cu29::prelude::Instant">Instant</a></dt><dt><a class="type" href="type.Iter.html" title="type cu29::prelude::Iter">Iter</a></dt><dt><a class="type" href="type.IterMut.html" title="type cu29::prelude::IterMut">IterMut</a></dt><dt><a class="type" href="type.NodeId.html" title="type cu29::prelude::NodeId">NodeId</a></dt><dd>NodeId is the unique identifier of a node in the configuration graph for petgraph
and the code generation.</dd></dl><h2 id="attributes" class="section-header">Attribute Macros<a href="#attributes" class="anchor">§</a></h2><dl class="item-table"><dt><a class="attr" href="attr.copper_runtime.html" title="attr cu29::prelude::copper_runtime">copper_<wbr>runtime</a></dt><dd>Adds #[copper_runtime(config = “path”, sim_mode = false/true)] to your application struct to generate the runtime.
if sim_mode is omitted, it is set to false.
This will add a “runtime” field to your struct and implement the “new” and “run” methods.</dd></dl><h2 id="derives" class="section-header">Derive Macros<a href="#derives" class="anchor">§</a></h2><dl class="item-table"><dt><a class="derive" href="derive.Serialize.html" title="derive cu29::prelude::Serialize">Serialize</a></dt></dl></section></div></main></body></html>