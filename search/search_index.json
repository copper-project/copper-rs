{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Copper Wiki \u00b6 Copper is a deterministic robotics runtime written in Rust. Think of it as a \"game engine for robots\": describe your system declaratively, compile the schedule, and run deterministically from cloud simulation down to embedded controllers. Why Copper - \u26a1 Sub-microsecond latency with a zero-alloc, data-oriented runtime. - \u23f1\ufe0f Deterministic replay for debugging and certification. - \ud83e\udde0 Interoperable with ROS 2 via bridges. - \ud83e\udeb6 Runs anywhere from x86 servers to bare metal. Ready to get started? Check out the README or jump into Build and Deploy a Copper Application . What's New \u00b6 \ud83d\udcdd Copper Release Notes Start Here \u00b6 Topic What you'll get Project Templates Scaffold a new Copper project quickly. Copper Application Overview A minimal task graph and runtime walkthrough. \ud83d\ude80 Build and Deploy a Copper Application Project structure, build artifacts, and deployment flow. \u2699\ufe0f Copper Configuration file Reference The RON schema for tasks, messages, and connections. Copper Runtime Overview Core runtime concepts and SDK capabilities. \ud83d\uddfa\ufe0f Copper Configuration and Mission Visualization Render task graphs and mission definitions. \ud83e\udded Copper Tasks lifecycle overview How tasks run, pause, and serialize state. \ud83e\udde9 Modular Configuration Split big configs into reusable chunks. Task Automation with just Repeatable task helpers across the repo. \ud83c\udf09 Copper Bridge concept Link Copper to external systems and protocols. \ud83e\uddf0 Resources Wire hardware and shared services into tasks and bridges. \ud83d\udd27 Baremetal Development Running Copper as a bare-metal runtime. \ud83d\udda5\ufe0f Supported Platforms Desktop, mobile, and embedded targets. Visual Overview \u00b6 Task Lifecycle Build and Deploy Missions Resources \u00b6 \ud83e\uddf1 List of available components SDK Features FAQ Roadmap \ud83d\udcda API Documentation on docs.rs \ud83e\uddea API \ud83d\udce6 Main crate on crates.io \ud83d\udcbb Source code on GitHub \ud83d\udee0\ufe0f Contributing guide","title":"Home"},{"location":"#copper-wiki","text":"Copper is a deterministic robotics runtime written in Rust. Think of it as a \"game engine for robots\": describe your system declaratively, compile the schedule, and run deterministically from cloud simulation down to embedded controllers. Why Copper - \u26a1 Sub-microsecond latency with a zero-alloc, data-oriented runtime. - \u23f1\ufe0f Deterministic replay for debugging and certification. - \ud83e\udde0 Interoperable with ROS 2 via bridges. - \ud83e\udeb6 Runs anywhere from x86 servers to bare metal. Ready to get started? Check out the README or jump into Build and Deploy a Copper Application .","title":"Copper Wiki"},{"location":"#whats-new","text":"\ud83d\udcdd Copper Release Notes","title":"What's New"},{"location":"#start-here","text":"Topic What you'll get Project Templates Scaffold a new Copper project quickly. Copper Application Overview A minimal task graph and runtime walkthrough. \ud83d\ude80 Build and Deploy a Copper Application Project structure, build artifacts, and deployment flow. \u2699\ufe0f Copper Configuration file Reference The RON schema for tasks, messages, and connections. Copper Runtime Overview Core runtime concepts and SDK capabilities. \ud83d\uddfa\ufe0f Copper Configuration and Mission Visualization Render task graphs and mission definitions. \ud83e\udded Copper Tasks lifecycle overview How tasks run, pause, and serialize state. \ud83e\udde9 Modular Configuration Split big configs into reusable chunks. Task Automation with just Repeatable task helpers across the repo. \ud83c\udf09 Copper Bridge concept Link Copper to external systems and protocols. \ud83e\uddf0 Resources Wire hardware and shared services into tasks and bridges. \ud83d\udd27 Baremetal Development Running Copper as a bare-metal runtime. \ud83d\udda5\ufe0f Supported Platforms Desktop, mobile, and embedded targets.","title":"Start Here"},{"location":"#visual-overview","text":"Task Lifecycle Build and Deploy Missions","title":"Visual Overview"},{"location":"#resources","text":"\ud83e\uddf1 List of available components SDK Features FAQ Roadmap \ud83d\udcda API Documentation on docs.rs \ud83e\uddea API \ud83d\udce6 Main crate on crates.io \ud83d\udcbb Source code on GitHub \ud83d\udee0\ufe0f Contributing guide","title":"Resources"},{"location":"Available-Components/","text":"Category Type Description Crate Name std no_std Board Bundles Flight Controller MicoAir H743 HAL bundle cu-micoairh743 \u274c \u2705 Sensors Lidar Velodyne/Ouster VLP16 cu-vlp16 \u2705 \u274c Lidar Hesai/XT32 cu-hesai \u2705 \u274c Lidar N/A Livox Tele15 cu-livox \u2705 \u274c Video Camera Video4Linux cu-v4l \u2705 \u274c Video Camera GStreamer appsink source cu-gstreamer \u2705 \u274c IMU WitMotion WT901 cu-wt901 \u2705 \u274c IMU N/A Bosch BMI088 6-axis IMU cu-bmi088 \u2705 \u2705 IMU N/A InvenSense MPU9250 IMU cu-mpu9250 \u2705 \u2705 ADC/Position ADS 7883 3MPSPS SPI ADC cu-ads7883 \u2705 \u274c Encoder Generic Directional Wheel encoder cu-rp-encoder \u2705 \u274c Actuators GPIO Raspberry Pi GPIO cu-rp-gpio \u2705 \u274c Servo Lewansoul Servo Bus (LX-16A, etc.) cu-lewansoul \u2705 \u274c DC Motor Driver Half-H Driver for CD Motors cu-rp-sn754410 \u2705 \u274c Algorithms Attitude Estimation N/A AHRS (attitude estimation) cu-ahrs \u2705 \u2705 PID Controller PID Controller cu-pid \u2705 \u2705 Time Alignment N/A Message time aligner cu-aligner \u2705 \u274c AprilTag Detection N/A AprilTag detection and pose cu-apriltag \u2705 \u274c Image Processing N/A Dynamic image thresholding cu-dynthreshold \u2705 \u274c Rate Limiter N/A Rate limiting task cu-ratelimit \u2705 \u274c Monitors TUI Monitor Console based monitor cu-consolemon \u2705 \u274c Log Monitor N/A Lightweight log monitor cu-logmon \u2705 \u2705 Middleware IPC Zenoh sink cu-zenoh-sink \u2705 \u274c IPC Iceroryx2 source Iceroryx2 sink cu-iceoryx2-src cu-iceoryx2-sink \u2705 \u274c ROS2 (Humble+) ROS2 sink over Zenoh cu-zenoh-ros-sink \u2705 \u274c Aero IPC (MSP) MSP bridge (serial) cu-msp-bridge \u2705 \u2705 Bridges ELRS / CRSF Radio ELRS/CRSF bridge cu-crsf \u2705 \u2705 Bidirectional DSHOT ESCs BDShot ESC bridge cu-bdshot \u274c \u2705 Legend: \u2705 supported, \u274c not supported/desktop-only.","title":"Available Components"},{"location":"Baremetal-Development/","text":"Baremetal Development with Copper \u00b6 Copper can also be deployed on baremetal ie. no-std on an MCU. The main advantage is that algorithms can be written to be usable on both normal (on an OS) and baremetal. The underlying logging format is also the same so you can extract the logs, replay in simulation what happened on the device, and debug with the comfort of a full local environment development and debugger. Getting Started \u00b6 Hardware (reference platform) \u00b6 We chose a beefed-up RP2350B-based board as a reference platform. It is very well-documented, relatively cheap, and a lot of peripherals and accessories are available. Overview: Note: we are not affiliated with any of those vendors or HW manufacturers. We just like them. If you want to receive the whole kit ready to be deployed with Copper : all soldered with the debug probe, a debug cable and tested. We can send you one: Ping us directly at info@copper-robotics.com. Base board \u00b6 It is a Pimoroni Pico plus 2W . Out of the box it has: - Powered by RP2350B (Dual Arm Cortex M33 running at up to 150MHz with 520KB of SRAM) - 16MB of QSPI flash supporting XiP - 8MB of PSRAM - USB-C connector for power, programming, and data transfer - Qw/ST (Qwiic/STEMMA QT) compatible I2C connector - 3 pin debug connector (JST-SH) - Reset and BOOT buttons (the BOOT button can also be used as a user button) - User LED indicator (addressable through the wifi chip though) - On-board 3V3 regulator (max regulator current output 600mA) - Input voltage range 3V - 5.5V You can buy it here: https://www.adafruit.com/product/6243 From the UK here: https://shop.pimoroni.com/products/pimoroni-pico-plus-2-w?variant=42182811942995 If you don't care about the Wi-Fi, you can opt for a simple plus 2: https://shop.pimoroni.com/products/pimoroni-pico-plus-2?variant=42092668289107 Extension boards to get a sdcard slot (to be able to log with Copper). \u00b6 Adafruit PiCowBell Camera Breakout (Here the 160 deg wide lens version): https://www.adafruit.com/product/5947 If you don't care about a camera: Adafruit PiCowbell Adalogger for Pico - MicroSD, RTC & STEMMA QT https://www.adafruit.com/product/5703a Or a simple, more compact alternative a break-out board just for the SD Card: Adafruit Proto Doubler (optional) \u00b6 This is a very nice addition for a bench setup. It allows you to connect the extension boards side by side with an extra row of pins you can use directly and some prototyping space underneath. https://www.adafruit.com/product/5906 Debug Probe HW \u00b6 It is highly recommended to use a debug probe: you'll be able to see the Copper structured logs in real-time, deploy from cargo run without having to reset the probe, set breakpoints etc... We recommend a CMSIS-DAP compliant debugger like the DAPLink-based ones: https://developer.arm.com/documentation/101451/0100/About-CMSIS-DAP because it works right out of the box with probe-rs , a Rust embedded probe tooling support. We had success with this one: https://github.com/WeActStudio/WeActStudio.MiniDebugger It is compact, with USB-C (most of the commercial probes are like tanks with USB-A), can provide a 5V power supply, and is straightforward to use. Be sure to buy the DapLink Version (not the ST-Link one). Debug probe cable and setup. \u00b6 There are 2 connectors to connect: - power - debug Power \u00b6 This allows you to just have to plug in a single USB-C connector on the probe side and the board will power itself up. This is the 5V connection on the probe side (see the picture above). You need to connect that to the VB (VBUS) pin on the board side. (NOT VS). Debug \u00b6 You now have to connect the SWDIO SWCLK and GND pins on the probe side to the SWDIO SWCLK and GND pins on the board side. Ideally, you want to crimp a JST-SH connector to the probe wires to be able to plug it directly into the board. Extra LEDs (optional) \u00b6 You can, for example, use some already made LED + resistor called lilypads: https://shop.pimoroni.com/en-us/products/lilypad-led-5pcs Here on plugged between pin 20 and GND. Ready to go for the rp2350 copper example. Software \u00b6 Quick sanity check \u00b6 Plug in your debugger and run dmesg , check to see if the board is detected. Install probe-rs: cargo install probe-rs-tools --locked Now check with probe-rs to see if the probe can connect to the board. First with a probe-rs list to see if the probe is detected and accessible. Then with probe-rs info --protocol swd to dump the target debug information. It should look like this: If not, check if your user has the right permissions to access the device. For example, you might want to add raw access to the USB devices with: $ cat /etc/udev/rules.d/60-cmsis-dap.rules # ARM mbed CMSIS-DAP (WeAct MiniDebugger DAPLink) VID:PID 0d28:0204 SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0d28\", ATTR{idProduct}==\"0204\", MODE=\"0660\", TAG+=\"uaccess\" SUBSYSTEM==\"hidraw\", ATTRS{idVendor}==\"0d28\", ATTRS{idProduct}==\"0204\", MODE=\"0660\", TAG+=\"uaccess\" Also, double-check your cable. Run the plain Copper example. \u00b6 In /examples/cu_rp2350_skeleton you can find a fully working example that will just flip the GPIO 21 and log the result on the SD card. First, plug an SD card on your computer and run the formatting script on it: support/mk_cu29_sdcard.sh <path to sdcard block device> You need wipefs and sgdisk installed for that (on Arch Linux, sudo pacman -S util-linux gptfdisk ) TRIPLE-CHECK THAT PATH TO THE SD CARD BLOCK DEVICE IS CORRECT, it will wipe out any disk you point it to. Here I monitor dmesg to see on which block device the SD card reader shows up and format it: You can also run into user rights issues, this one you can sudo out of it sudo support/mk_cu29_sdcard.sh <YOUR DEVICE> Run the Copper example with the debug probe. \u00b6 go to /examples/cu_rp2350_skeleton and run cargo run-arm You should see the Copper text logs streaming right through the debugger. With it finding the SD card and starting to log on it. The LED on GPIO 21 should blink. Extract the logs. \u00b6 If you want to see the tasks data logs (copperlists), directly dump the partition to a file (basically recreating a slab): $ # here substiture with your own device, probably the same as the one you formatted the sdcard with $ pv /dev/sdb2 > logs/blinky_0.copper Then you can dump the logs with exactly like a standard Copper log file, note we made also a shortcut for the log reader: Note: no _0 suffix here, the log reader figures out the slab number automatically. $ cargo run-logreader extract-copperlists logs/blinky.copper Resim \u00b6 If you check the src/tasks.rs file, you'll see that the tasks are just standard Copper tasks. You can resimulate the log the same way as any other Copper programs (+/- managing the std/no-std variations), check the examples folder for resim examples. Caveats \u00b6 The logs don't get closed correctly, it should not prevent you from reading them but it is annoying. You can implement a button to drop the Copper instance and force the correct closure of the logs.","title":"Baremetal Development"},{"location":"Baremetal-Development/#baremetal-development-with-copper","text":"Copper can also be deployed on baremetal ie. no-std on an MCU. The main advantage is that algorithms can be written to be usable on both normal (on an OS) and baremetal. The underlying logging format is also the same so you can extract the logs, replay in simulation what happened on the device, and debug with the comfort of a full local environment development and debugger.","title":"Baremetal Development with Copper"},{"location":"Baremetal-Development/#getting-started","text":"","title":"Getting Started"},{"location":"Baremetal-Development/#hardware-reference-platform","text":"We chose a beefed-up RP2350B-based board as a reference platform. It is very well-documented, relatively cheap, and a lot of peripherals and accessories are available. Overview: Note: we are not affiliated with any of those vendors or HW manufacturers. We just like them. If you want to receive the whole kit ready to be deployed with Copper : all soldered with the debug probe, a debug cable and tested. We can send you one: Ping us directly at info@copper-robotics.com.","title":"Hardware (reference platform)"},{"location":"Baremetal-Development/#base-board","text":"It is a Pimoroni Pico plus 2W . Out of the box it has: - Powered by RP2350B (Dual Arm Cortex M33 running at up to 150MHz with 520KB of SRAM) - 16MB of QSPI flash supporting XiP - 8MB of PSRAM - USB-C connector for power, programming, and data transfer - Qw/ST (Qwiic/STEMMA QT) compatible I2C connector - 3 pin debug connector (JST-SH) - Reset and BOOT buttons (the BOOT button can also be used as a user button) - User LED indicator (addressable through the wifi chip though) - On-board 3V3 regulator (max regulator current output 600mA) - Input voltage range 3V - 5.5V You can buy it here: https://www.adafruit.com/product/6243 From the UK here: https://shop.pimoroni.com/products/pimoroni-pico-plus-2-w?variant=42182811942995 If you don't care about the Wi-Fi, you can opt for a simple plus 2: https://shop.pimoroni.com/products/pimoroni-pico-plus-2?variant=42092668289107","title":"Base board"},{"location":"Baremetal-Development/#extension-boards-to-get-a-sdcard-slot-to-be-able-to-log-with-copper","text":"Adafruit PiCowBell Camera Breakout (Here the 160 deg wide lens version): https://www.adafruit.com/product/5947 If you don't care about a camera: Adafruit PiCowbell Adalogger for Pico - MicroSD, RTC & STEMMA QT https://www.adafruit.com/product/5703a Or a simple, more compact alternative a break-out board just for the SD Card:","title":"Extension boards to get a sdcard slot (to be able to log with Copper)."},{"location":"Baremetal-Development/#adafruit-proto-doubler-optional","text":"This is a very nice addition for a bench setup. It allows you to connect the extension boards side by side with an extra row of pins you can use directly and some prototyping space underneath. https://www.adafruit.com/product/5906","title":"Adafruit Proto Doubler (optional)"},{"location":"Baremetal-Development/#debug-probe-hw","text":"It is highly recommended to use a debug probe: you'll be able to see the Copper structured logs in real-time, deploy from cargo run without having to reset the probe, set breakpoints etc... We recommend a CMSIS-DAP compliant debugger like the DAPLink-based ones: https://developer.arm.com/documentation/101451/0100/About-CMSIS-DAP because it works right out of the box with probe-rs , a Rust embedded probe tooling support. We had success with this one: https://github.com/WeActStudio/WeActStudio.MiniDebugger It is compact, with USB-C (most of the commercial probes are like tanks with USB-A), can provide a 5V power supply, and is straightforward to use. Be sure to buy the DapLink Version (not the ST-Link one).","title":"Debug Probe HW"},{"location":"Baremetal-Development/#debug-probe-cable-and-setup","text":"There are 2 connectors to connect: - power - debug","title":"Debug probe cable and setup."},{"location":"Baremetal-Development/#power","text":"This allows you to just have to plug in a single USB-C connector on the probe side and the board will power itself up. This is the 5V connection on the probe side (see the picture above). You need to connect that to the VB (VBUS) pin on the board side. (NOT VS).","title":"Power"},{"location":"Baremetal-Development/#debug","text":"You now have to connect the SWDIO SWCLK and GND pins on the probe side to the SWDIO SWCLK and GND pins on the board side. Ideally, you want to crimp a JST-SH connector to the probe wires to be able to plug it directly into the board.","title":"Debug"},{"location":"Baremetal-Development/#extra-leds-optional","text":"You can, for example, use some already made LED + resistor called lilypads: https://shop.pimoroni.com/en-us/products/lilypad-led-5pcs Here on plugged between pin 20 and GND. Ready to go for the rp2350 copper example.","title":"Extra LEDs (optional)"},{"location":"Baremetal-Development/#software","text":"","title":"Software"},{"location":"Baremetal-Development/#quick-sanity-check","text":"Plug in your debugger and run dmesg , check to see if the board is detected. Install probe-rs: cargo install probe-rs-tools --locked Now check with probe-rs to see if the probe can connect to the board. First with a probe-rs list to see if the probe is detected and accessible. Then with probe-rs info --protocol swd to dump the target debug information. It should look like this: If not, check if your user has the right permissions to access the device. For example, you might want to add raw access to the USB devices with: $ cat /etc/udev/rules.d/60-cmsis-dap.rules # ARM mbed CMSIS-DAP (WeAct MiniDebugger DAPLink) VID:PID 0d28:0204 SUBSYSTEM==\"usb\", ATTR{idVendor}==\"0d28\", ATTR{idProduct}==\"0204\", MODE=\"0660\", TAG+=\"uaccess\" SUBSYSTEM==\"hidraw\", ATTRS{idVendor}==\"0d28\", ATTRS{idProduct}==\"0204\", MODE=\"0660\", TAG+=\"uaccess\" Also, double-check your cable.","title":"Quick sanity check"},{"location":"Baremetal-Development/#run-the-plain-copper-example","text":"In /examples/cu_rp2350_skeleton you can find a fully working example that will just flip the GPIO 21 and log the result on the SD card. First, plug an SD card on your computer and run the formatting script on it: support/mk_cu29_sdcard.sh <path to sdcard block device> You need wipefs and sgdisk installed for that (on Arch Linux, sudo pacman -S util-linux gptfdisk ) TRIPLE-CHECK THAT PATH TO THE SD CARD BLOCK DEVICE IS CORRECT, it will wipe out any disk you point it to. Here I monitor dmesg to see on which block device the SD card reader shows up and format it: You can also run into user rights issues, this one you can sudo out of it sudo support/mk_cu29_sdcard.sh <YOUR DEVICE>","title":"Run the plain Copper example."},{"location":"Baremetal-Development/#run-the-copper-example-with-the-debug-probe","text":"go to /examples/cu_rp2350_skeleton and run cargo run-arm You should see the Copper text logs streaming right through the debugger. With it finding the SD card and starting to log on it. The LED on GPIO 21 should blink.","title":"Run the Copper example with the debug probe."},{"location":"Baremetal-Development/#extract-the-logs","text":"If you want to see the tasks data logs (copperlists), directly dump the partition to a file (basically recreating a slab): $ # here substiture with your own device, probably the same as the one you formatted the sdcard with $ pv /dev/sdb2 > logs/blinky_0.copper Then you can dump the logs with exactly like a standard Copper log file, note we made also a shortcut for the log reader: Note: no _0 suffix here, the log reader figures out the slab number automatically. $ cargo run-logreader extract-copperlists logs/blinky.copper","title":"Extract the logs."},{"location":"Baremetal-Development/#resim","text":"If you check the src/tasks.rs file, you'll see that the tasks are just standard Copper tasks. You can resimulate the log the same way as any other Copper programs (+/- managing the std/no-std variations), check the examples folder for resim examples.","title":"Resim"},{"location":"Baremetal-Development/#caveats","text":"The logs don't get closed correctly, it should not prevent you from reading them but it is annoying. You can implement a button to drop the Copper instance and force the correct closure of the logs.","title":"Caveats"},{"location":"Build-and-Deploy-a-Copper-Application/","text":"Here is a quick illustration of how to build and deploy a Copper application. \u00b6 At compile time, cargo build or cargo build -r will generate 3 artifacts. 1. the actual binary that will run on the target. 2. a log reader that will allow you to read the logs generated by your robots. 3. a string index directory that will be necessary to reconstruct the log strings from the copper binary log file.","title":"Build and Deploy a Copper Application"},{"location":"Build-and-Deploy-a-Copper-Application/#here-is-a-quick-illustration-of-how-to-build-and-deploy-a-copper-application","text":"At compile time, cargo build or cargo build -r will generate 3 artifacts. 1. the actual binary that will run on the target. 2. a log reader that will allow you to read the logs generated by your robots. 3. a string index directory that will be necessary to reconstruct the log strings from the copper binary log file.","title":"Here is a quick illustration of how to build and deploy a Copper application."},{"location":"Config-and-Missions-Visualization/","text":"In order to visualize a configuration and the mission you can use this command: cargo run -p cu29-runtime --bin cu29-rendercfg -- examples/cu_bridge_test/copperconfig.ron It should produce a file in the current directory called output.svg containing a graph like this with all the missions: You can also list the missions from the config or only render a specific mission check --help for details: $ cargo run -p cu29-runtime --bin cu29-rendercfg -- --help Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.15s Running `target/debug/cu29-rendercfg --help` Copper Runtime Runtime crate. Copper is an engine for robotics. Usage: cu29-rendercfg [OPTIONS] <CONFIG> Arguments: <CONFIG> Config file name Options: --mission <MISSION> Mission id to render (omit to render every mission) --list-missions List missions contained in the configuration and exit --open Open the SVG in the default system viewer -h, --help Print help -V, --version Print version","title":"Copper Configuration and Mission Visualization"},{"location":"Copper-Application-Overview/","text":"Copper Application Overview \u00b6 This page shows a minimal Copper application: a task graph definition in RON and the Rust code that implements a simple task and runtime. Task graph (RON) \u00b6 ( tasks: [ ( id: \"src\", type: \"FlippingSource\", ), ( id: \"gpio\", type: \"cu_rp_gpio::RPGpio\", config: { \"pin\": 4, }, ), ], cnx: [ (src: \"src\", dst: \"gpio\", msg: \"cu_rp_gpio::RPGpioMsg\"), ], ) Runtime and task implementation (Rust) \u00b6 use std::path::PathBuf; use cu29::prelude::*; #[copper_runtime(config = \"copperconfig.ron\")] struct MyApplication {} pub struct FlippingSource { state: bool, } impl CuSrcTask for FlippingSource { type Output<'m> = output_msg!(RPGpioPayload); fn new(config: Option<&copper::config::ComponentConfig>) -> CuResult<Self> where Self: Sized, { Ok(Self { state: true }) } fn process(&mut self, clock: &RobotClock, output: &mut Self::Output<'_>) -> CuResult<()> { self.state = !self.state; output.set_payload(RPGpioPayload { on: self.state, creation: Some(clock.now()).into(), actuation: Some(clock.now()).into(), }); Ok(()) } } fn main() { let logger_path = \"/tmp/mylogfile.copper\"; let copper_ctx = basic_copper_setup(&PathBuf::from(logger_path), true).expect(\"Failed to setup logger.\"); debug!(\"Logger created at {}.\", logger_path); let clock = copper_ctx.clock; debug!(\"Creating application... \"); let mut application = MyApplication::new(clock.clone(), copper_ctx.unified_logger.clone()) .expect(\"Failed to create runtime.\"); debug!(\"Running... starting clock: {}.\", clock.now()); application.run().expect(\"Failed to run application.\"); debug!(\"End of program: {}.\", clock.now()); } For a deeper explanation of task lifecycle hooks and scheduling, see Task Lifecycle .","title":"Copper Application Overview"},{"location":"Copper-Application-Overview/#copper-application-overview","text":"This page shows a minimal Copper application: a task graph definition in RON and the Rust code that implements a simple task and runtime.","title":"Copper Application Overview"},{"location":"Copper-Application-Overview/#task-graph-ron","text":"( tasks: [ ( id: \"src\", type: \"FlippingSource\", ), ( id: \"gpio\", type: \"cu_rp_gpio::RPGpio\", config: { \"pin\": 4, }, ), ], cnx: [ (src: \"src\", dst: \"gpio\", msg: \"cu_rp_gpio::RPGpioMsg\"), ], )","title":"Task graph (RON)"},{"location":"Copper-Application-Overview/#runtime-and-task-implementation-rust","text":"use std::path::PathBuf; use cu29::prelude::*; #[copper_runtime(config = \"copperconfig.ron\")] struct MyApplication {} pub struct FlippingSource { state: bool, } impl CuSrcTask for FlippingSource { type Output<'m> = output_msg!(RPGpioPayload); fn new(config: Option<&copper::config::ComponentConfig>) -> CuResult<Self> where Self: Sized, { Ok(Self { state: true }) } fn process(&mut self, clock: &RobotClock, output: &mut Self::Output<'_>) -> CuResult<()> { self.state = !self.state; output.set_payload(RPGpioPayload { on: self.state, creation: Some(clock.now()).into(), actuation: Some(clock.now()).into(), }); Ok(()) } } fn main() { let logger_path = \"/tmp/mylogfile.copper\"; let copper_ctx = basic_copper_setup(&PathBuf::from(logger_path), true).expect(\"Failed to setup logger.\"); debug!(\"Logger created at {}.\", logger_path); let clock = copper_ctx.clock; debug!(\"Creating application... \"); let mut application = MyApplication::new(clock.clone(), copper_ctx.unified_logger.clone()) .expect(\"Failed to create runtime.\"); debug!(\"Running... starting clock: {}.\", clock.now()); application.run().expect(\"Failed to run application.\"); debug!(\"End of program: {}.\", clock.now()); } For a deeper explanation of task lifecycle hooks and scheduling, see Task Lifecycle .","title":"Runtime and task implementation (Rust)"},{"location":"Copper-RON-Configuration-Reference/","text":"Copper RON Configuration Reference \u00b6 This guide explains how to configure a Copper application using RON files. It summarises the available sections and options based on the source code and example configurations. Basic Structure \u00b6 A Copper configuration is a RON file containing tasks, connections and optional sections such as monitoring, logging or runtime settings. The minimal form looks like: ( tasks: [], cnx: [], ) Most examples name the file copperconfig.ron and reference it with the #[copper_runtime(config = \"...\")] attribute. Tasks \u00b6 Tasks are declared under the tasks array. Each task entry is a tuple with the following fields: id \u2013 unique identifier of the task. type \u2013 fully qualified Rust type of the task implementation. config (optional) \u2013 map of parameters passed to the task. missions (optional) \u2013 list of mission ids in which this task is active. background (optional) \u2013 when set to true , the task runs on a background thread. logging (optional) \u2013 { enabled: bool } to enable or disable message logging for this task. Example: ( id: \"task1\", type: \"tasks::ExampleTask\", background: true, logging: (enabled: false), ) Connections \u00b6 Connections are declared under cnx as tuples describing edges between tasks: src \u2013 id of the source task. dst \u2013 id of the destination task. msg \u2013 Rust type of the message carried. missions (optional) \u2013 restrict the connection to specific missions. Example: (src: \"task0\", dst: \"task1\", msg: \"i32\") Monitoring \u00b6 The optional monitor section selects a monitoring component and its parameters: monitor: ( type: \"cu_consolemon::CuConsoleMon\", config: { \"verbosity\": 2 }, ) Logging \u00b6 The logging section tunes Copper\u2019s structured log. Options mirror the fields of LoggingConfig defined in core/cu29_runtime/src/config.rs : enable_task_logging \u2013 controls per-task logging (defaults to true ). slab_size_mib \u2013 size of each memory mapped slab in MiB. section_size_mib \u2013 pre\u2011allocated size per log section in MiB. keyframe_interval \u2013 number of copperlists between two keyframes (default 100 ). Example from examples/cu_logging_size : logging: ( slab_size_mib: 1024, section_size_mib: 100, ) The library validates that section_size_mib does not exceed slab_size_mib . Runtime Settings \u00b6 Runtime behaviour can be adjusted with the runtime section. Currently only rate_target_hz is available: runtime: ( rate_target_hz: 2, ) This acts as a rate limiter for Copper list execution. Missions \u00b6 Configurations may define multiple missions, each representing an alternative task graph: missions: [ (id: \"A\"), (id: \"B\") ] Tasks and connections can specify a missions array to belong only to selected missions. See examples/cu_missions/copperconfig.ron for a complete example. Modular Configuration \u00b6 Copper supports composition of configurations using the includes section. Each include specifies a path and optional parameter substitutions: includes: [ ( path: \"base.ron\", params: { \"id\": \"left\", \"pin\": 4 }, ), ] Included files are processed recursively. Parameters are substituted in the included text using the {{param}} syntax. Merging behaviour and further details are described in doc/modular_config.md . Example \u00b6 A more complete configuration demonstrating several features is provided in examples/modular_config_example/main_config.ron : ( tasks: [], cnx: [], monitor: ( type: \"cu_consolemon::CuConsoleMon\" ), logging: ( file: \"robot.copper\", level: \"debug\" ), includes: [ ( path: \"base.ron\", params: {} ), ( path: \"motors.ron\", params: { \"id\": \"left\", \"pin\": 4, \"direction\": \"forward\" } ), ( path: \"motors.ron\", params: { \"id\": \"right\", \"pin\": 5, \"direction\": \"reverse\" } ), ], ) Further Reading \u00b6 For advanced composition rules and best practices see the Modular Configuration guide .","title":"Copper Configuration file Reference"},{"location":"Copper-RON-Configuration-Reference/#copper-ron-configuration-reference","text":"This guide explains how to configure a Copper application using RON files. It summarises the available sections and options based on the source code and example configurations.","title":"Copper RON Configuration Reference"},{"location":"Copper-RON-Configuration-Reference/#basic-structure","text":"A Copper configuration is a RON file containing tasks, connections and optional sections such as monitoring, logging or runtime settings. The minimal form looks like: ( tasks: [], cnx: [], ) Most examples name the file copperconfig.ron and reference it with the #[copper_runtime(config = \"...\")] attribute.","title":"Basic Structure"},{"location":"Copper-RON-Configuration-Reference/#tasks","text":"Tasks are declared under the tasks array. Each task entry is a tuple with the following fields: id \u2013 unique identifier of the task. type \u2013 fully qualified Rust type of the task implementation. config (optional) \u2013 map of parameters passed to the task. missions (optional) \u2013 list of mission ids in which this task is active. background (optional) \u2013 when set to true , the task runs on a background thread. logging (optional) \u2013 { enabled: bool } to enable or disable message logging for this task. Example: ( id: \"task1\", type: \"tasks::ExampleTask\", background: true, logging: (enabled: false), )","title":"Tasks"},{"location":"Copper-RON-Configuration-Reference/#connections","text":"Connections are declared under cnx as tuples describing edges between tasks: src \u2013 id of the source task. dst \u2013 id of the destination task. msg \u2013 Rust type of the message carried. missions (optional) \u2013 restrict the connection to specific missions. Example: (src: \"task0\", dst: \"task1\", msg: \"i32\")","title":"Connections"},{"location":"Copper-RON-Configuration-Reference/#monitoring","text":"The optional monitor section selects a monitoring component and its parameters: monitor: ( type: \"cu_consolemon::CuConsoleMon\", config: { \"verbosity\": 2 }, )","title":"Monitoring"},{"location":"Copper-RON-Configuration-Reference/#logging","text":"The logging section tunes Copper\u2019s structured log. Options mirror the fields of LoggingConfig defined in core/cu29_runtime/src/config.rs : enable_task_logging \u2013 controls per-task logging (defaults to true ). slab_size_mib \u2013 size of each memory mapped slab in MiB. section_size_mib \u2013 pre\u2011allocated size per log section in MiB. keyframe_interval \u2013 number of copperlists between two keyframes (default 100 ). Example from examples/cu_logging_size : logging: ( slab_size_mib: 1024, section_size_mib: 100, ) The library validates that section_size_mib does not exceed slab_size_mib .","title":"Logging"},{"location":"Copper-RON-Configuration-Reference/#runtime-settings","text":"Runtime behaviour can be adjusted with the runtime section. Currently only rate_target_hz is available: runtime: ( rate_target_hz: 2, ) This acts as a rate limiter for Copper list execution.","title":"Runtime Settings"},{"location":"Copper-RON-Configuration-Reference/#missions","text":"Configurations may define multiple missions, each representing an alternative task graph: missions: [ (id: \"A\"), (id: \"B\") ] Tasks and connections can specify a missions array to belong only to selected missions. See examples/cu_missions/copperconfig.ron for a complete example.","title":"Missions"},{"location":"Copper-RON-Configuration-Reference/#modular-configuration","text":"Copper supports composition of configurations using the includes section. Each include specifies a path and optional parameter substitutions: includes: [ ( path: \"base.ron\", params: { \"id\": \"left\", \"pin\": 4 }, ), ] Included files are processed recursively. Parameters are substituted in the included text using the {{param}} syntax. Merging behaviour and further details are described in doc/modular_config.md .","title":"Modular Configuration"},{"location":"Copper-RON-Configuration-Reference/#example","text":"A more complete configuration demonstrating several features is provided in examples/modular_config_example/main_config.ron : ( tasks: [], cnx: [], monitor: ( type: \"cu_consolemon::CuConsoleMon\" ), logging: ( file: \"robot.copper\", level: \"debug\" ), includes: [ ( path: \"base.ron\", params: {} ), ( path: \"motors.ron\", params: { \"id\": \"left\", \"pin\": 4, \"direction\": \"forward\" } ), ( path: \"motors.ron\", params: { \"id\": \"right\", \"pin\": 5, \"direction\": \"reverse\" } ), ], )","title":"Example"},{"location":"Copper-RON-Configuration-Reference/#further-reading","text":"For advanced composition rules and best practices see the Modular Configuration guide .","title":"Further Reading"},{"location":"Copper-Release-Notes/","text":"v0.11.0 - 2025-11-26 \u00b6 High Level \u00b6 In this release we are introducing a new type of tasks: Bridges to help users implement multi-channel transports (serial, CAN, ELRS radios, ESC buses\u2026). Technically they are like a set of our existing sources and sinks bundled into one logical component, it makes it easier to manage state from external systems and Copper. This release also delivers the minimum viable set of crates to build a Copper-native flight controller! MSP messaging, PID control, ELRS/CRSF radio links, and bidirectional DSHOT ESCs all run in no_std . Flight controllers are only the first vertical we are bootstrapping but we will rotate through specialties (driving, etc...) to continue to give some basic components to get you started quickly with Copper. New Features \u00b6 CuBridge Runtime + docs Bridge landed end-to-end: config parsing ([#490]), runtime scheduling ([#495]), and graph APIs ([#491], [#500]) now understand multi-channel transports with typed payloads and shared resources. The new CuBridge Concept page explains how to declare Tx/Rx channel sets, map them in missions, and extend bridge lifecycles. A cu_bridge_test example ([#509]) pairs with the monitoring tooling so you can dry-run bridges locally before flashing firmware. Bridge-aware monitoring & graphing cu_consolemon renders bridges directly in the TUI DAG ([#510], [#511]) and the live graph now matches the DOT export down to the shared transport connectors ([#512], [#513]). Flight Controller SDK (MVP / Prototype) \u00b6 We are waiting for a couple of rp2350-based FC boards to test it in flight but if you are interested to start developing your own, it works very well on our devkit with the SDcard logging support etc. MSP everywhere ( no_std + bridge) The MSP library/bridge combo is now fully no_std and built on top of the new cu_embedded_registry , so you can share UART handles between copper crates on MCUs (bda362600, [#516]). MSP (MultiWii Serial Protocol) remains the lingua franca for controllers such as INAV, Cleanflight, and Betaflight; the bridge exposes batch Tx/Rx channels so Copper tasks can stream RC data, sensor packets, or tuning commands without rewriting MSP plumbing. PID controller in firmware cu_pid drops its std dependency and uses only alloc , letting you tune and run PID loops directly on bare-metal targets ([#514]). Tasks that already use the PID helper on Linux now compile unchanged for firmware. ELRS/CRSF bridge ( std + no_std ) The radio link supports both environments, shares serial ports via the embedded registry, and routes telemetry back into Copper so you can log link quality or failsafe events alongside flight data ([#498], bda362600). Bidirectional DSHOT (RP2350 only for now) DSHOT is the digital ESC bus flight controllers use to send throttle commands and receive telemetry on the same wire; the RP2350 bridge drives ESCs with DSHOT800 timings, decodes the one-wire telemetry bursts, and exposes four static channels into the task graph ([#497]). MSP + PID + CRSF + DSHOT are the core building blocks for a Copper flight controller today, and extending the stack is just writing more Rust tasks/bridges. Remote Ops & Telemetry \u00b6 ELRS/CRSF remote operation stack cu_crsf gained the same std / no_std duality as the rest of the bridge family, so the exact radio link you use to operate a Copper robot over ExpressLRS works both on host testbeds and MCUs ([#498], bda362600). The bridge speaks CRSF for RC commands and streams link quality, battery, and failsafe telemetry down the same radio pipe, and the new cu_elrs_bdshot_demo shows it driving ESCs from a handheld radio out of the box. Bidirectional DSHOT flight stack demo cu_bdshot encapsulates the RP2350 PIO/DMA programming needed to control four bidirectional DSHOT ESCs and collect their telemetry ([#497]). Combined with the ELRS bridge you can run a remote pilot loop\u2014commands in, ESC telemetry out\u2014entirely in Copper. Bug Fixes \u00b6 The simulation generation was not able to generate a Sink proxy (replacing your actual task and callbacking the sim) if you were listening to 2 other tasks as input. This is fixed with ([#512]). Thank @matthewashton-k for your patience on this one. Enhancements \u00b6 We made some monitoring TUI visual improvements (more compact, nicer icons and merging connectors) CuBridge UX polish : optional routes on bridge channels ([#499]) and assorted QoL cleanups ([#500]) make mission authoring less verbose. Vendored TUI nodes : we now ship a patched tui-nodes copy tailored for bridge rendering inside cu_consolemon . Weekly CI : embedded-crate detection got smarter so ARM-only components stay exercised automatically ([#507]). Dependency refresh : ron 0.12 ([#503]), cudarc 0.18 ([#504]), and rerun 0.27 ([#506]) keep the desktop toolchain current. no more rkv : After a discussion with Mozilla it was clear that they won't support the lmdb backend we used for storing our string indexes for our structured logging. We swapped the implementation to a very dumb lock + bincode dump. At some point we will improve that with a system similar to what defmt uses (that is scalable per compiled crate). no more console corruption : there was ways the system could quit from cu-consolemon without restoring properly the console, we fixed them ([#526]). Special thanks \u00b6 Yang Zhou for making our Weekly CI keep up with this crazy pace of development! v0.10.0 - 2025-10-19 \u00b6 High Level \u00b6 Major milestone: baremetal support lands across the stack, SD/eMMC logging backends, CMSIS-DAP probe workflow. RP2350 is the reference platform; examples and scripts are included. New Features \u00b6 Baremetal (no_std) end-to-end Ported core crates and runtime to no_std and added embedded tests to CI ([#444], [#446], [#447], [#449], [#450], [#451], [#452], [#453], [#454], [#455], [#456], [#457], [#458], [#459], [#460], [#461], [#466], [#467], [#468]) RP2350 Reference Example examples/cu_rp2350_skeleton a \"blinky\" example for Copper on its reference platform to get you started quickly. Pairs with docs and a formatting script for the Copper log partition on SDCards. ([#467], [#468]) RobotClock with Calibration (baremetal + host) New calibrated clock that accepts an external reference (RTC/GPS/etc.) on embedded and desktop; raw counter access standardized. ([#478]) Logging straigth to a filesystem partition: SD / eMMC logging backends Embedded backends for unified logging ([#473], [#474]) CMSIS-DAP probe workflow + defmt bridge Probe defaults, cargo run deploy loop via probe; bridged the Copper logging to defmt for MCU-friendly debugging. ([#470]) Host vs Firmware split Cleaner tree and CI: host utilities (incl. run-logreader ) live outside firmware paths. ([#476]) More tolerant log reader No longer panics on unclosed logs; returns an error instead. ([#477]) Enhancements \u00b6 Stabilized std/no_std/sim combos and removed legacy host feature in favor of explicit std flags where applicable. ([#462]) Config & runtime refactors for embedded storage backends in CuApplication . ([#472]) v0.9.1 - 2025-09-12 \u00b6 High Level \u00b6 Point release improving simulation control, fixing task indexing bugs, and refreshing several dependencies for long-term maintenance. New Features \u00b6 run_in_sim for Sources & Sinks ([#431]) Override Copper\u2019s default sim stubbing for hardware endpoints. Useful when your sim must keep talking to external middleware (ROS bridge, Zenoh, etc.). ron ( tasks: [ ( id: \"ros_bridge\", type: \"tasks::RosBridgeSink\", run_in_sim: true, // real sink runs even in sim ), ] ) Bug Fixes \u00b6 Task output index calculation fixed to select the correct output slot. ([#426]) Index into output arrays now uses node_id rather than output_position . ([#430]) Threadpool use-after-move resolved by cloning the pool correctly; improves stability for background tasks. ([#416]) cu-monitor empty status crash removed legacy workaround that caused crashes. ([#415]) Crates.io metadata corrected for publication. ([#414]) CI : disabled Windows CUDA runner until upstream action is fixed. ([#424]) Dependency Updates \u00b6 ron \u2192 0.11.0 (API changes adapted). ([#427]) pyo3 \u2192 0.26.0 (ported to new API). ([#429]) cached-path \u2192 0.9.0 . ([#428]) nalgebra \u2192 0.34.0 . ([#420]) cudarc \u2192 0.17.0 . ([#419]) GitHub Actions: Jimver/cuda-toolkit 0.2.26 \u2192 0.2.27 . ([#425]) GitHub Actions: actions/checkout v5 . ([#423]) v0.9.0 - 2025-07-31 \u00b6 High Level \u00b6 This release is primarily driven by user requests. It introduces a full transform library (\u00e0 la tf2 for ROS), new keyframes in the logs, background tasks, a log checker, and a set of runtime and logging tuning parameters to better adapt to constrained environments. API Change \u00b6 The task API now uses finer-grained lifetimes for input and output types. This provides greater flexibility when testing tasks and was necessary to support the implementation of background tasks: Old API: impl<'cl> CuSrcTask<'cl> for FlippingSource { type Output = output_msg!('cl, RPGpioPayload); fn process(&mut self, clock: &RobotClock, output: Self::Output) -> CuResult<()> { self.state = !self.state; // Flip our internal state and send the message in our output. output.set_payload(RPGpioPayload { on: self.state, creation: Some(clock.now()).into(), actuation: Some(clock.now()).into(), }); Ok(()) } } There are two changes required to port your tasks: The lifetime has moved from <'cl> on the task struct to <'m> on the Input and Output types. The process method now takes explicit references: & for input and &mut for output. impl CuSrcTask for FlippingSource { type Output<'m> = output_msg!(RPGpioPayload); # ^^^^ fn process(&mut self, clock: &RobotClock, output: &mut Self::Output<'_>) -> CuResult<()> { # ^^^^ ^^^^ self.state = !self.state; // Flip our internal state and send the message in our output. output.set_payload(RPGpioPayload { on: self.state, creation: Some(clock.now()).into(), actuation: Some(clock.now()).into(), }); Ok(()) } } New Component: cu_transform \u00b6 The cu_transform crate provides real-time spatial and velocity transformations for Copper, with support for hierarchical frames, interpolation, and zero-allocation caching. Huge thank you to @makeecat for this feature! Features \u00b6 Homogeneous matrix representation of 3D transforms Time-stamped pose updates and interpolated lookups Hierarchical transform tree with parent-child frames Velocity computation via transform differentiation Rigid-body velocity frame transformations High-performance caching for repeated transform/velocity queries Zero-allocation for real-time performance Example: Pose Lookup \u00b6 use cu_transform::{StampedTransform, TransformTree, Transform3D}; use cu29::clock::CuDuration; let mut tree = TransformTree::<f32>::new(); tree.add_transform(StampedTransform { transform: Transform3D::default(), stamp: CuDuration(1000), parent_frame: \"world\".try_into()?, child_frame: \"robot\".try_into()?, })?; let pose = tree.lookup_transform(\"world\", \"robot\", CuDuration(1000))?; Example: Velocity Lookup \u00b6 use cu_transform::TransformTree; use cu29::clock::CuDuration; let velocity = tree.lookup_velocity(\"world\", \"robot\", CuDuration(1500))?; let linear = velocity.linear_velocity(); let angular = velocity.angular_velocity(); This component is ideal for real-time robotic applications needing fast, correct spatial and motion reasoning across dynamic coordinate frames. New Features \u00b6 background tasks : we now have a best effort asynchronous task type. Be careful to use memory handles if you feed them a large amount of data has the input and output need to be copied to allow the asynchronism to work. How to use it? just add background: true to any CuTask (not Src nor Sink). ( tasks: [ ( id: \"task1\", type: \"tasks::ExampleTask\", background: true, // that's it ), ] The result will be set in a random future CopperList so for the downstream tasks keep a close eye on the input.tov field to know from where this message is coming from. Note: We have not implemented the deterministic replay yet for those, but it will come in an upcoming release. logreader fsck : we now have a cool tool to not only check for the consistency of a Copper log and giving you some explanation of any corruption, it gives out some cool statistics about the logs: pal \u279c cu_caterpillar (master) cargo run -r --bin cu-caterpillar-logreader logs/caterpillar.copper fsck The log checked out OK. === Statistics === Total time -> 1.481 s Total used size -> 14,120,984 bytes Logging rate -> 9.09 MiB/s (effective) # of CL -> 20,303 CL rate -> 13,708.96 Hz CL total size -> 10,384,994 bytes # of Keyframes -> 3 KF rate -> 2.03 Hz KF total size -> 28 bytes # of SL entries -> 162,433 SL total size -> 3,735,962 bytes Added a runtime rate target configuration (#410): Copper can be too fast, especially with the introduction of background tasks. We added a way to rate limit the CopperList creation, exactly like a frame rate limiter would work in games because probably your robot doesn't need 500KHz refresh rates normal use cases. For example limit at 100Hz: ( runtime: ( rate_target_hz: 100, ), tasks: [ Adds a way to disable logging for some tasks. (#407) With the determinism built in Copper, you might not want to log everything. We added a way to disable the logging of any task output. It will keep the metadata of the output though (Time of Validity, Status string ....) tasks: [ ( // Normal id: \"task0\", type: \"tasks::ExampleSrc\", ), ( id: \"task1\", type: \"tasks::ExampleTask\", logging: ( enabled: false, // HERE, no more logging for this one ) ), Keyframes (#369): Now Copper is able to record \"keyframe\" ie. the serialized state of all the tasks during runtime, sim or resim. This will allow nifty debugger features. force Serialize implementation on CuMsg : This guarantees that the log reader can at least reexport the messages to all the SerDe backends. cu-dorabench : a new benchmark more geared toward bandwith more than just latency. Enhancements \u00b6 CuStampData : a lot of robotics data needs to be timestamped and this is also true for the CuMsg between tasks. We have generalized this concept so you can use a contained with a time of validity and arbitrary metadata for your own internal use in your tasks and libraries. // CuMsg is now defined as type CuMsg<P> = CuStampData<P, CuMsgMetadata>; // And now TOV (the time of validity for this temporal data) is directly accessible in the main object instead of the metadata let mut m: CuMsg<u32> = CuMsg::new(12); m.tov = CuDuration(1000).into(); // You can define temporal data types for yourself for example type MyTemporalData = CuStampData<f64, ()>; // And use them directly as a field in your tasks. resim implemented for cu-caterpillar (#364): added that to our venerable example to test out various logger features easily. cargo cubuild (#365): helps you debug when a change causes a code compilation error in the generated code. Just use that instead of build and it will insert the generated code at the macros spot and compile it. CuCompactString : Better log and debug output showing the string nicely. Bug fixes \u00b6 Unified Logger Poisoned lock (#390): We had a cascading error when the main thread would panic and drop the logger. Task DAG in the Monitoring UI is slow (#391): Thanks to Matthew Ashton-Knochel from working with tui-nodes folks to optimise the direct rendering mode of it. Restored the original log debug behavior (#381): if nothing is specified -> debug builds enable log-debug, -> release buids enable log-info. if anything is specified, it will repect the user's choice. Unconditionally install ctrl-c handler (#375): instead of relying on user's code to handle that as it can cause easy log corruption. Fix CuCompactString initialization CuListsManager (#409): a zero init of the copper list created status strings that are all 24x \\\\0 . This fixes it with a correct initialzation that set them at length 0 instead. It was wasting a bunch of log space for no reason. Dependency updates \u00b6 socket2 -> 0.6.0 cuda-toolkit -> 0.2.26 gstreamer & gstreamer-app -> 0.24 rerun -> 0.24 glam -> 0.30.x thiserror -> 2.x v0.8.0 - 2025-05-26 \u00b6 High level \u00b6 This release has been focused on Zenoh and ROS2 interoperability, modular configuration for larger robots with a new support for the notion of \"mission\" (aka mode like autonomy mode, datacollect mode etc..) New Features \u00b6 Copper to ROS2 Integration : We now support streaming Copper data directly to ROS2 (rwm_zenoh). This includes a working example bridging Copper tasks to ROS2 nodes and a translation layer for Copper message representations. See PR #348 . Zenoh Sink : Added a zenoh_sink component to forward Copper messages to any other Zenoh participant with the serialization of your choice. Thanks to @kamibo ( #316 ). Missions System : You can now define and generate missions from RON, with automatic default fallback. Missions are properly serialized, structured, and support reuse through includes. ( #337 , #294 ) Modular Configuration System : Copper now supports reusable and parameterized config files. This feature introduces relative/absolute file includes, parameter substitution using {{param}} syntax, and well-defined merging rules. You can now split large config files into logical components and reuse templates with different parameters. Example templates are included under the modular_config_example directory. Thanks to @makeecat ( #328 ) Memory Pool Monitoring UI : Copper's monitoring console cu-consolemon now includes a dedicated page to visualize memory pool usage in real time. It displays total preallocated memory, in-use buffers, memory handles in flight, and the allocation rate. This provides better observability into buffer-heavy pipelines using CopperLists and memory pools. Thanks to @makeecat for implementing this! ( #190 ) CuRateLimit Task : A new CuRateLimit task lets you easily throttle any message flow without modifying the producing task. See #343 . Copper Application Trait : Introduced a trait to generalize Copper applications. Enables grouping and dynamic handling of mission-defined applications. ( #345 ) Nix Setup : Introduced Nix setup for Linux, supporting CUDA / non-CUDA environment. Thanks to @makeecat ! ( #332 ) Enhancements \u00b6 Compile-time log-level macro : Copper now supports compile-time log filtering for logs. This feature lets you fully disable logging macros at compile time by enabling only the relevant features in Cargo.toml . It introduces a log-level field in CuLogEntry , and updates serialization, formatting, and documentation accordingly. Thanks to @makeecat ! ( #318 ) Example usage: [dependencies] cu29 = { version = \"0.7.0\", features = [\"log-level-debug\"] } CuGraph Separation : Graph-related functionality has been extracted into its own module to reduce coupling between configuration and execution layers. ( #334 ) Bevy 0.16 Support : Copper is now compatible with Bevy 0.16, including updated patches for asset loading and avian3d. Thanks to @makeecat ( #303 ). Support for iceoryx2 v0.6.1 : Iceoryx2 backend updated and patched accordingly. ( #338 ) Dockerization of ros-caterpillar : ros-caterpillar has been fully containerized to deal with OS dependency hell. It is now portable and future-proof. ( #348 ) Dependency Bumps \u00b6 iceoryx2-bb-log bumped to 0.6.1 ( #340 ) uom bumped to 0.37.0 ( #339 ) Other crates : cached-path , iyes_perf_ui , faer , ron , petgraph , nix , etc. updated to support Bevy 0.16 and latest Rust editions. v0.7.0 - 2025-03-14 \u00b6 High level \u00b6 This release added a set of feature useful to develop autonomy algorithms on Drone (MSP). We also have a solid set of quality of life improvements derived from real usage. Notable regression \u00b6 bincode after 4 years stuck at the 2.0.0-rc3 decided to release the 2.0.0 and it broke the API. This release updates all our API calls. The good news is that decoding in memory pools are now supported, it will be useful. New Features \u00b6 gstreamer support You can define arbitraty gstreamer pipeline and hook it as an appsink to Copper are a SrcTask [#239] This for example a source that will get the camera from your robot, stream it to a host on your network for live display but also convert it to GRAY8 and inject it to the Copper task graph. ( id: \"video\", type: \"cu_gstreamer::CuDefaultGStreamer\", config: { \"pipeline\": \"v4l2src device=/dev/video9 ! image/jpeg,width=1920,height=1080 ! tee name=t t. ! queue ! jpegdec ! videoconvert ! appsink name=copper t. ! queue ! jpegparse ! rtpjpegpay ! udpsink host=192.168.1.73 port=5000\", \"caps\": \"video/x-raw, format=GRAY8, width=1920, height=1080\", }, ), Dynamic Threshold . A quick 0 copy implementation using an integral image. [#244] April Tag support . It can give you the relative pose of tags from images. [#246] ( id: \"pos\", type: \"cu_apriltag::AprilTags\", config: { \"tag_family\": \"tag16h5\", \"tag_size\": 0.14, \"fx\": 1513.93, \"fy\": 1513.93, \"cx\": 946.84, \"cy\": 557.819, }, ), MSP (MultiWii Serial Protocol) This is a communication protocol used on drones with INAV, cleanflight, betafligh [#248] Added 2 new robotics standard messages: Transform3D and Pose [#245] They can be transformed back and forth with into() from Faer and Nalgebra so you can integrate that to your robotics algorithms smoothly. let pose = Transform3D { mat: [ [1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [9.0, 10.0, 11.0, 12.0], [13.0, 14.0, 15.0, 16.0], ], }; Quality of life improvements \u00b6 The Cu29 crate has a new global debug_macro feature to be able to see any generation (runtime, structured logging, SOAs etc...) [#247] PyO3 (the python bindings for log reading) is now an optional feature [#240] Thanks Mike Kaliman! The Input order in the tuples of tasks receiving messages from more than one taask is now determined by their order of connection [#251] Thanks @hscoelho ! Better feedback when a task sends an error to the runtime. Ie. now it actually triggers a debug! with the error description instead of just giving you the result of the monitoring behavior. CuTime now support Copy which makes clock forwarding more immediate. Bevy perf-ui is back (overlay for bevy) and can be used in your simulations (see cu-balancebot) [#263] Thanks @AS1100K ! And finally special thanks to @makeecat for the ongoing help on the CI/CD that starts to be a complicated piece of machinery at this point. v0.6.0 - 2025-01-20 \u00b6 New Features \u00b6 Images support : We added the API to make a pool instance and bind is as a [u8] for an image buffer, see below about Memory Pools. Video For Linux 2 support : We built a V4L2 source so you can read images directly from you video system on Linux. The component is named cu_v4l here are an example of parameters to can set in your RON file: config: { \"device\": 0, // The /dev/video0 device \"width\": 3840, // Width asked \"height\": 2160, // Height asked \"fps\": 30, // image rate \"fourcc\": \"NV12\", // buffer format \"buffers\": 4, // how many buffers you want to allocate \"timeout_ms\": 500, // time before giving up on trying to get a frame } https://github.com/user-attachments/assets/0858026d-bf92-418f-9525-3df5d5de9b70 Computer Vision: Kornia API support : Kornia is an awesome Computer Vision set of algorithms. The 2 projects cooperated to we can map Copper images to Kornia and Kornia can accept them with 0 copy! Check out the Kornia-rs project . Big thanks to the creator of this project Edgar Riba for his support! 0-Copy Heterogeneous Memory Pools : Said wut? Before this release anything the tasks would touch (as input or output) would have been needed to be copied in the CopperList ie. the backing structure that makes Copper so fast and low latency with no synchronization etc. Building a complex robot is the art of having not only low latency like this but also large throughput: this is the large throughput side of Copper for modern computer architectures! You can create large memory buffers pools either in main host memory or on a \"device\" for example a GPU (this is what heterogeneous memory means) and Copper will give you memory handles that you can use to: - pass the memory to another task - pass the memory to the accelerator that can use it (for example CUDA kernels see below) - pass the memory to a DMA backed driver (see the new V4L driver below) For you developer, it means that you can safely stream multi-megabytes structures (Images, Matrices, PointClouds etc..) at no cost and you also buffer them in tasks if you need to keep them for a few cycle more (for temporal alignment for example). New Basic Livox Lidar Tele15 Driver : Thanks to @luc-k1 from Konboi One. New Debug log pane in cu-consolemon : Before that you had to choose between the cool TUI and the text log (that was hidden behind) but thanks to @AS1100K effort we now have a tab that can capture your debug logs! (it is only enabled if you want them as they are expensive to build and if the app is build in debug mode). Pcap replay support : for drivers reading data from the network, it is very common to build a test set from network capture. This is a little tool that help driver developer to inject those capture and build a small test data set to validate their driver. Quicksort on PointCloud SOA ts : Sorting by time of validity allows the points to get merged more efficiently. 2 lidar sources getting merged. Enhancements \u00b6 Prelude : we drastically simplified the imports for Copper, now you just need to do: use cu29::prelude::*; And you are good to go for starting Copper, creating tasks, etc... More flexible project generation : The template will ask you which version of Copper you want to generate your project for. Log parameter in RON : Added the section_size parameter in the RON file. It is useful to tune your logging throughput. Builder pattern for the Copper Application : we made the CopperContext official and change the app init to be with a cool builder pattern like: let mut application = CaterpillarApplicationBuilder::new() .with_context(&copper_ctx) .build() .expect(\"Failed to create application.\"); Thanks to @hscoelho for this one! Log disable : Now you can disable task logging completely (if you know you won't need the data). Thanks to @AS1100K ! Better feedback on configuration snafu : We improved the clarity of the messages given to the user with a line number if possible in case of misconfiguration... Thanks again to @AS1100K ! Full dependency update : Enjoy the latest Bevy, the latest Rerun, the latest everything thanks to @makeecat . This includes the new picker that has been integrated to Bevy. Logger Parameters Consistency : We now check if the various parameters of the unified logger makes sense ie. section not larger than slabs etc.. that avoids a lot of user confusion. Clippy escaped our CI/CD again but thanks to an heroic effort from @makeecat we have a major improvement on our CI/CD to cross check all the platforms, features and configurations. -= op on CuTime, it is useful to compute quickly time offsets. ScopedAllocCounter : we improved their use by exposing a sane public API so you can check if you or one of your dependency is allocating in a given scope. Thanks to Zac8668 Bug Fixes \u00b6 X11 support for Bevy on Linux : Apparently some people have not migrated to Wayland yet :P. Thanks @Paulotten Missing ./logs would make cu-balancebot-sim crash: thanks @vsenn for reporting this. v0.5.1 - 2024-12-05 \u00b6 New Features \u00b6 Microsoft Windows Compatibility is finally complete #129 : So many thanks to @Lishen_ for the unwaivering bruteforce port. Rerun visualization for pointclouds #131 : Added an example to start and feed rerun visualization with our standard pointcloud Enhancements \u00b6 BalanceBot Simulation perf overlay #137 : Now you can activate the perf-ui feature to see if the bevy side of the simulation is working well in a diag overlay. Iterators For SOAs (Struct of arrays) #134 : SOAs can generate an iterator for a quick SOA to AOS transform and natural API. Bug Fixes \u00b6 BalanceBot Simulation Issues #137 : Resolved a waste of resources on balancebot-sim (the bevy entities were created over and over). Thanks to @Nashenas88 for spotting the issure and the initial fix. Pointcloud payload and Hesai structs visibility fix #132 & #133 : Snafu as they were published with no client crates. Multiple gammar fixes #125 : Thanks to @AnyTimeTraveler for all the corrected Frenglish. v0.5.0 - 2024-12-02 \u00b6 New Features \u00b6 Deterministic Log Replay : Copper can now replay a log through your code in a deterministic fashion ie. if your tasks are deterministic, it will always output the same output from the same input! See the balancebot-resim for example. Aligner Task #114 : Added an aligner task that synchronizes multiple inputs by aligning matching time windows, facilitating coordinated data processing. This is particularly useful for sensor fusion. :exclamation: Lifecycle Trait Removal #115 : Removed the lifecycle trait to simplify task implementation and decouple passed types, streamlining the codebase. To build a minimum task a user needed to implement one method from the CuTaskLifecycle trait (new) and at least the process method from they flavor of tasks. This was forcing the implementation of 2 mandatory traits which is not necessary or useful for the user. Now we moved all the lifecycle methods in the tasks trait to only have to implement 2 traits (the task and Freezable, the serialization of its state) Enhancements \u00b6 Named Output Mapping on CopperLists #121 : Implemented mapping of Copperlist indices to named outputs from tasks, allowing users to access task outputs symbolically without relying on execution order. CuTimeRange Introduction #106 : Introduced CuTimeRange to represent messages containing multiple Time of Validity (TOV) instances, such as sequences of images or IMU measurements. Windows Compatibility #110 : Enhanced compatibility by adding a mock for cu_ads7883 , enabling compilation on Windows platforms. Dependency Updates #104 : Performed a general dependency bump post-release to incorporate the latest improvements and fixes. Faster SOA ops : adding len to the public API allows quicker preallocations. f32 shortcut for dimensions and reflectivity for Lidars : simple from f32 makes it easier to not deal too much with the units. Bug Fixes \u00b6 BalanceBot Simulation Stability #118 : Resolved a core dump issue on exit for balancebot-sim by enforcing specific graphics backends, ensuring clean termination. CuCompactStr Serialization #119 : Fixed serialization and deserialization issues with CuCompactStr to ensure correct data handling. Project Generation Fix #120 : Addressed issues in project generation by adding crate:: for cumsgs generation, ensuring correct module resolution. Unused Code Cleanup #121 : Removed unused imports and methods to maintain code cleanliness and reduce potential maintenance overhead. Test Stability #107 : Ignored hardware-dependent tests and added test --workspace to CI/CD to enhance test reliability across different environments. v0.4.1 - 2024-11-15 \u00b6 New Features \u00b6 Iceoryx2 Support #87 : Introduced Iceoryx2 support. Iceoryx2 is the successor to Iceoryx in pure Rust. The Copper support included a source component to receive messages, a sink component to send messages. Hesai XT32 Support #101 : Added the preliminary support for the Hesai XT32. If you have the actual HW handy, feel free to provide us the feedback! First standard Lidar Message Design #99 : For now in SOA out or the lidar sensors it allows SIMD optimizations for the first operations that are usually a frame transform. Enhancements \u00b6 Variable-Length SoAs #100 : Improved SoA (Structure of Arrays) to support variable lengths on top of their fixed size in the Copper List. CI Improvements #98 : Integrated clippy warnings into CI, thanks to makeecat Bug Fixes \u00b6 BalanceBot Simulation Reset #86 : Improved the reset_sim functionality for the balance bot. Thanks to makeecat . Publishing Fixes #103 : Resolved various publishing issues and added dry-run validations to avoid disruptions. v0.4.0 - 2024-10-29 \u00b6 New Features \u00b6 Simulation API Support : With sim-mode=true in the main Copper macro, Copper will generate for you all the callbacks at all the tasks states it is going through (Start, Preprocess, Process, etc...). Combined with the already mockable Clock it allows a very easy integration with a virtual environment. BalanceBot Simulation #69 : Built on that and leveraging Bevy and Avian3D for realistic motion dynamics, we made a little demo of our little real world demonstrator. The real world code and the sim code are 100% identical. Config Embedding #78 : Embedded the default copperconfig.ron directly into the Copper executable, simplifying deployment for the main case (just one executable to copy and that's it!!). If the file is present, it will take precedence over the embedded version. We also do log the actual config used in the logs so you can come back to it in doubt. Enhancements \u00b6 Cross-Platform Compatibility for Mocking #75 : Enhanced feature flags to better support various platforms, particularly macOS, enabling testing with mocked hardware dependencies. The full repo now compile under CI/CD on MacOS and Linux (previously it we could only compile and test the Core) Bug Fixes \u00b6 Terminal Restoration #73 : Fixed issues with terminal states not restoring properly upon exit, preventing corruption and enhancing the overall stability of simulator sessions. Print Output Cleanup #80 : Streamlined console logging to minimize redundant or unnecessary print statements, making debugging output more manageable. Git LFS Migration #76 : Moved heavy assets to a CDN to mitigate GitHub LFS limitations, reducing operational overhead and streamlining asset distribution. Infrastructure and CI/CD \u00b6 Asset CDN Integration #35 : Transitioned assets to a content delivery network to avoid the super costly Github LFS. Improved Documentation #82 : Expanded and refined documentation across modules, enhancing clarity for new users and developers. Internal Refactoring \u00b6 Logging Value Enhancements #80 : Fine-tuned value logging to increase logging granularity and simplify troubleshooting in complex simulation states. Feature Flag Revamp #75 : Restructured feature flags to better support debugging and cross-platform configurations, especially for macOS compatibility. v0.3.1 - 2024-10-12 \u00b6 A Minor release with 2 new components and some fixes. New Components \u00b6 New cu-pid task: this is the first algorithm we publish. It is from the balancebot, a generalized PID controller logic you can reuse in your projects, see the readme in the crate. New cu-consolemon monitoring: this is a TUI for Copper showing the information exposed by the new monitoring interface released in 0.3.0. API improvements \u00b6 Added Mul to CuDuration for easy time offset computations. Various \u00b6 Tree Reorganization : Major reorganization of the repository structure for improved clarity and maintainability. Bug Fixes \u00b6 Logging Fixes : Resolved an issue where OnceLock was not releasing the unified logger, preventing a clean shutdown of the logger. Addressed an issue with a double close in the logger during shutdown. v0.3.0 - 2024-09-30 \u00b6 This alpha release introduces substantial improvements to the Copper framework's monitoring capabilities and API flexibility. Highlights \u00b6 New multisource and optional input API : The Copper engine now supports multiple and optional inputs/outputs (see PR #44). This is a breaking change . Now you can link 2 tasks to one in the RON file like this: tasks: [ ( id: \"balpos\", type: \"cu_ads7883::ADS7883\", ), ( id: \"railpos\", type: \"cu_rp_encoder::Encoder\", ), ( id: \"pidctrl\", type: \"pidtask::PIDTask\", config: { [...] }, ), ( id: \"motor\", type: \"cu_rp_sn754410::SN754410\", [...] ), ], cnx: [ // vvvvvvvvvv same dest! (src: \"balpos\", dst: \"pidctrl\", msg: \"cu_ads7883::ADSReadingPayload\"), (src: \"railpos\", dst: \"pidctrl\", msg: \"cu_rp_encoder::EncoderPayload\"), (src: \"pidctrl\", dst: \"motor\", msg: \"cu_rp_sn754410::MotorPayload\"), ], ) To help you manage the types that are generated, we are giving a set of macros to help you matching the correct input / output types: impl<'cl> CuTask<'cl> for PIDTask { // This tasks takes 2 inputs! // They are given in the order of task declaration // the input_msg! macro build a (&CuMsg<ADSReadingPayload>, &CuMsg<EncoderPayload>) tuple under the hood. // it also works with 1 input and then you will get a straight &CuMsg<> immutable ref. // For technical Rust reasons, you need to explicitely tie the lifetime ('cl means copperlist if you are curious: the internal structure of copper for messages) type Input = input_msg!('cl, ADSReadingPayload, EncoderPayload); // same thing but as an output this is a &mut CuMsg<MotorPayload> type Output = output_msg!('cl, MotorPayload); fn process( &mut self, clock: &RobotClock, input: Self::Input, // here this is now straight the input type, it is a little simpler. output: Self::Output, ) -> CuResult<()> { let (bal_pos, rail_pos) = input; // you can unpack the tuple directly those are resp. &CuMsg<ADSReadingPayload> and &CuMsg<EncoderPayload> let bal_tov = bal_pos.metadata.tov.expect(\"we should have had a message here!\"); // the messages are now optional depending on the context they could be expected or really optional. // we have a new method called set_payload for the output output.set_payload(MotorPayload { power: 0.0 }); // If you don't do that it will send away a message with a None payload Monitoring System : The monitoring framework is now fully integrated, allowing real-time stats collection and cumulative statistics (see PRs #49, #50, and #51). We can imagine complex decision trees happening at that stage for complex robots and various degraded modes. The monitoring component is really similar to a task, but with specialized callbacks: // This is in the RON file, just add a monitor entry like this: tasks: [ ( id: \"task0\", type: \"tasks::ExampleSrc\", ), [...] ], cnx: [ (src: \"task0\", dst: \"task1\", msg: \"i32\"), [...] ], monitor: (type: \"ExampleMonitor\") // here, add a config entry if necessary ) struct ExampleMonitor { tasks: &'static [&'static str], // We give you the task ordinal to task id mapping (so it is stable as long as you don't change your task ids. } impl CuMonitor for ExampleMonitor { // We pass you the config you gave in the RON file exactly like for the tasks. fn new(_config: Option<&ComponentConfig>, taskids: &'static [&str]) -> CuResult<Self> { Ok(ExampleMonitor { tasks: taskids }) } fn start(&mut self, clock: &_RobotClock) -> CuResult<()> { // callbacked when all the tasks, start called. } fn process_copperlist(&self, msgs: &[&CuMsgMetadata]) -> CuResult<()> { // This is callbacked at the end of the processing of a copper list (basically near when the CL is getting serialized to disk after a success. // The metadata gives you all the timings you need to check if your robot is still behaving nominally. for t in msgs.iter().enumerate() { let (taskid, metadata) = t; debug!(\"Task: {} -> {}\", taskid, metadata); } Ok(()) } fn process_error(&self, taskid: usize, step: CuTaskState, error: &CuError) -> Decision { // This is called back if any task reports an error at any step (start, process, ...) // You can then match that taskid and compute a decision for your robot: Abort, Ignore, Shutdown (see the cu28/monitoring.rs file for semantic details. Decision::Ignore } fn stop(&mut self, clock: &_RobotClock) -> CuResult<()> { // call when the stack is stopping Ok(()) } } Other Notable Changes \u00b6 New Features \u00b6 Real-time cumulative stats for CuDurations . See cu29/monitoring.rs we built an histogramming feature for timings this is super useful for monitoring components. Here is the list of everything you get it is not only pretty comprehensive but it is fixed size on memory so it should be pretty swift for any real time monitoring needs or UIs. // on the CuDurationStatistics struct pub fn min(&self) -> CuDuration; pub fn max(&self) -> CuDuration; pub fn mean(&self) -> CuDuration pub fn percentile(&self, percentile: f64) -> CuDuration; pub fn stddev(&self) -> CuDuration; pub fn jitter_min(&self) -> CuDuration; pub fn jitter_max(&self) -> CuDuration; pub fn jitter_mean(&self) -> CuDuration; pub fn jitter_stddev(&self) -> CuDuration; pub fn jitter_percentile(&self, percentile: f64) -> CuDuration; Fixes \u00b6 Serialization / Deserialization Bug on Value (#42). A code reformat shuffled the serialization IDs Oo. Enhancements \u00b6 Virtual Output for Sinks (#53): before that there was no mean to monitor sinks (or hacks you might have seen on the incoming message). Now the stack behind the scene generates a () empty message for each sink you you get the perf number cleanly for them even if they don't output anything. Balance Bot Demo (#46): a more complete example of a real robot demo we will bring at conferences. Miscellaneous \u00b6 And a bunch of cleanup / doc improments. Copper - v0.2.3 - 2024-09-11 \u00b6 We are pleased to announce the release of Copper v0.2.3, which includes several new features, enhancements, and bug fixes. Below is a summary of the key changes in this release: New Features \u00b6 SN754410 Driver Support #40 : Added a new driver for the SN754410 motor driver. This driver allows easy integration with motor control applications, providing robust support for H-bridge motor control on a wide range of systems. This driver is fully compatible with the BalanceHAT. ADS7883 Driver #39 : Introduced a driver for the ADS7883, a 12-bit SPI ADC. This addition includes comprehensive documentation in the README to facilitate setup and integration. The ADS7883 driver is also compatible with the BalanceHAT. Enhancements \u00b6 macOS Development Support #25 : Copper can now be developed on macOS! The CI/CD pipeline has been updated to support macOS, ensuring cross-platform compatibility for all users. cu29_clock Enhancements #32 : Added a division feature to the cu29_clock, allowing more granular time management and synchronization within the Copper runtime. Structured Log Index File in Debug Mode #30 : Removed the requirement for an index file in debug mode within struct_log, simplifying the debugging process ie. only the config and the executable needs to be deployed for the debug build and you get a standard debug text logging. Logging Slabs Addition #24 : The current unified logger works with big memory mapped files. Initially we thought we could rely on the mmap resize feature of the kernel api but it just doesn't work. We are reverting into building \"slabs\", ie dividing the data logger into large files. Those files can be concatenated and read or directly read from the log exporter. Bug Fixes \u00b6 Compilation Feedback Adjustments #33 : Moved compilation feedback from standard output to standard error to better align with conventional logging practices. Flush and Core Dump Fixes #29 : Resolved issues where changes after a section flush could cause a core dump, improving the stability of the logging system. Infrastructure and CI/CD \u00b6 CI/CD Pipeline Enhancements #25 : Added macOS support to the CI/CD pipeline, ensuring better cross-platform compatibility. Removed 'Continue on Error' in CI/CD #36 : Addressed a CI/CD issue where the pipeline was green while failing Oo. Refactoring and Internal Changes \u00b6 Unified Logger Refactor #27 : Refactored the Unified Logger to introduce a dual-slab logging system, improving performance and eliminating the need for remap/resize operations. Runtime Loop Enhancements #21 : Added a new notion of loops in the runtime plan, setting the stage for more flexible and powerful runtime behavior. If you're looking to build your own interfacing with the SN754410 or ADS7883 drivers, we share detailed connectivity schematics with a Raspberry Pi to help you get started. We recommend updating to this latest version to take advantage of these improvements. As always, please refer to the updated documentation and release notes for detailed information on how to integrate these changes into your projects. If you have any questions or need further assistance, feel free to reach out to our support team.","title":"Copper Release Notes"},{"location":"Copper-Release-Notes/#v0110-2025-11-26","text":"","title":"v0.11.0 - 2025-11-26"},{"location":"Copper-Release-Notes/#high-level","text":"In this release we are introducing a new type of tasks: Bridges to help users implement multi-channel transports (serial, CAN, ELRS radios, ESC buses\u2026). Technically they are like a set of our existing sources and sinks bundled into one logical component, it makes it easier to manage state from external systems and Copper. This release also delivers the minimum viable set of crates to build a Copper-native flight controller! MSP messaging, PID control, ELRS/CRSF radio links, and bidirectional DSHOT ESCs all run in no_std . Flight controllers are only the first vertical we are bootstrapping but we will rotate through specialties (driving, etc...) to continue to give some basic components to get you started quickly with Copper.","title":"High Level"},{"location":"Copper-Release-Notes/#new-features","text":"CuBridge Runtime + docs Bridge landed end-to-end: config parsing ([#490]), runtime scheduling ([#495]), and graph APIs ([#491], [#500]) now understand multi-channel transports with typed payloads and shared resources. The new CuBridge Concept page explains how to declare Tx/Rx channel sets, map them in missions, and extend bridge lifecycles. A cu_bridge_test example ([#509]) pairs with the monitoring tooling so you can dry-run bridges locally before flashing firmware. Bridge-aware monitoring & graphing cu_consolemon renders bridges directly in the TUI DAG ([#510], [#511]) and the live graph now matches the DOT export down to the shared transport connectors ([#512], [#513]).","title":"New Features"},{"location":"Copper-Release-Notes/#flight-controller-sdk-mvp-prototype","text":"We are waiting for a couple of rp2350-based FC boards to test it in flight but if you are interested to start developing your own, it works very well on our devkit with the SDcard logging support etc. MSP everywhere ( no_std + bridge) The MSP library/bridge combo is now fully no_std and built on top of the new cu_embedded_registry , so you can share UART handles between copper crates on MCUs (bda362600, [#516]). MSP (MultiWii Serial Protocol) remains the lingua franca for controllers such as INAV, Cleanflight, and Betaflight; the bridge exposes batch Tx/Rx channels so Copper tasks can stream RC data, sensor packets, or tuning commands without rewriting MSP plumbing. PID controller in firmware cu_pid drops its std dependency and uses only alloc , letting you tune and run PID loops directly on bare-metal targets ([#514]). Tasks that already use the PID helper on Linux now compile unchanged for firmware. ELRS/CRSF bridge ( std + no_std ) The radio link supports both environments, shares serial ports via the embedded registry, and routes telemetry back into Copper so you can log link quality or failsafe events alongside flight data ([#498], bda362600). Bidirectional DSHOT (RP2350 only for now) DSHOT is the digital ESC bus flight controllers use to send throttle commands and receive telemetry on the same wire; the RP2350 bridge drives ESCs with DSHOT800 timings, decodes the one-wire telemetry bursts, and exposes four static channels into the task graph ([#497]). MSP + PID + CRSF + DSHOT are the core building blocks for a Copper flight controller today, and extending the stack is just writing more Rust tasks/bridges.","title":"Flight Controller SDK (MVP / Prototype)"},{"location":"Copper-Release-Notes/#remote-ops-telemetry","text":"ELRS/CRSF remote operation stack cu_crsf gained the same std / no_std duality as the rest of the bridge family, so the exact radio link you use to operate a Copper robot over ExpressLRS works both on host testbeds and MCUs ([#498], bda362600). The bridge speaks CRSF for RC commands and streams link quality, battery, and failsafe telemetry down the same radio pipe, and the new cu_elrs_bdshot_demo shows it driving ESCs from a handheld radio out of the box. Bidirectional DSHOT flight stack demo cu_bdshot encapsulates the RP2350 PIO/DMA programming needed to control four bidirectional DSHOT ESCs and collect their telemetry ([#497]). Combined with the ELRS bridge you can run a remote pilot loop\u2014commands in, ESC telemetry out\u2014entirely in Copper.","title":"Remote Ops &amp; Telemetry"},{"location":"Copper-Release-Notes/#bug-fixes","text":"The simulation generation was not able to generate a Sink proxy (replacing your actual task and callbacking the sim) if you were listening to 2 other tasks as input. This is fixed with ([#512]). Thank @matthewashton-k for your patience on this one.","title":"Bug Fixes"},{"location":"Copper-Release-Notes/#enhancements","text":"We made some monitoring TUI visual improvements (more compact, nicer icons and merging connectors) CuBridge UX polish : optional routes on bridge channels ([#499]) and assorted QoL cleanups ([#500]) make mission authoring less verbose. Vendored TUI nodes : we now ship a patched tui-nodes copy tailored for bridge rendering inside cu_consolemon . Weekly CI : embedded-crate detection got smarter so ARM-only components stay exercised automatically ([#507]). Dependency refresh : ron 0.12 ([#503]), cudarc 0.18 ([#504]), and rerun 0.27 ([#506]) keep the desktop toolchain current. no more rkv : After a discussion with Mozilla it was clear that they won't support the lmdb backend we used for storing our string indexes for our structured logging. We swapped the implementation to a very dumb lock + bincode dump. At some point we will improve that with a system similar to what defmt uses (that is scalable per compiled crate). no more console corruption : there was ways the system could quit from cu-consolemon without restoring properly the console, we fixed them ([#526]).","title":"Enhancements"},{"location":"Copper-Release-Notes/#special-thanks","text":"Yang Zhou for making our Weekly CI keep up with this crazy pace of development!","title":"Special thanks"},{"location":"Copper-Release-Notes/#v0100-2025-10-19","text":"","title":"v0.10.0 - 2025-10-19"},{"location":"Copper-Release-Notes/#high-level_1","text":"Major milestone: baremetal support lands across the stack, SD/eMMC logging backends, CMSIS-DAP probe workflow. RP2350 is the reference platform; examples and scripts are included.","title":"High Level"},{"location":"Copper-Release-Notes/#new-features_1","text":"Baremetal (no_std) end-to-end Ported core crates and runtime to no_std and added embedded tests to CI ([#444], [#446], [#447], [#449], [#450], [#451], [#452], [#453], [#454], [#455], [#456], [#457], [#458], [#459], [#460], [#461], [#466], [#467], [#468]) RP2350 Reference Example examples/cu_rp2350_skeleton a \"blinky\" example for Copper on its reference platform to get you started quickly. Pairs with docs and a formatting script for the Copper log partition on SDCards. ([#467], [#468]) RobotClock with Calibration (baremetal + host) New calibrated clock that accepts an external reference (RTC/GPS/etc.) on embedded and desktop; raw counter access standardized. ([#478]) Logging straigth to a filesystem partition: SD / eMMC logging backends Embedded backends for unified logging ([#473], [#474]) CMSIS-DAP probe workflow + defmt bridge Probe defaults, cargo run deploy loop via probe; bridged the Copper logging to defmt for MCU-friendly debugging. ([#470]) Host vs Firmware split Cleaner tree and CI: host utilities (incl. run-logreader ) live outside firmware paths. ([#476]) More tolerant log reader No longer panics on unclosed logs; returns an error instead. ([#477])","title":"New Features"},{"location":"Copper-Release-Notes/#enhancements_1","text":"Stabilized std/no_std/sim combos and removed legacy host feature in favor of explicit std flags where applicable. ([#462]) Config & runtime refactors for embedded storage backends in CuApplication . ([#472])","title":"Enhancements"},{"location":"Copper-Release-Notes/#v091-2025-09-12","text":"","title":"v0.9.1 - 2025-09-12"},{"location":"Copper-Release-Notes/#high-level_2","text":"Point release improving simulation control, fixing task indexing bugs, and refreshing several dependencies for long-term maintenance.","title":"High Level"},{"location":"Copper-Release-Notes/#new-features_2","text":"run_in_sim for Sources & Sinks ([#431]) Override Copper\u2019s default sim stubbing for hardware endpoints. Useful when your sim must keep talking to external middleware (ROS bridge, Zenoh, etc.). ron ( tasks: [ ( id: \"ros_bridge\", type: \"tasks::RosBridgeSink\", run_in_sim: true, // real sink runs even in sim ), ] )","title":"New Features"},{"location":"Copper-Release-Notes/#bug-fixes_1","text":"Task output index calculation fixed to select the correct output slot. ([#426]) Index into output arrays now uses node_id rather than output_position . ([#430]) Threadpool use-after-move resolved by cloning the pool correctly; improves stability for background tasks. ([#416]) cu-monitor empty status crash removed legacy workaround that caused crashes. ([#415]) Crates.io metadata corrected for publication. ([#414]) CI : disabled Windows CUDA runner until upstream action is fixed. ([#424])","title":"Bug Fixes"},{"location":"Copper-Release-Notes/#dependency-updates","text":"ron \u2192 0.11.0 (API changes adapted). ([#427]) pyo3 \u2192 0.26.0 (ported to new API). ([#429]) cached-path \u2192 0.9.0 . ([#428]) nalgebra \u2192 0.34.0 . ([#420]) cudarc \u2192 0.17.0 . ([#419]) GitHub Actions: Jimver/cuda-toolkit 0.2.26 \u2192 0.2.27 . ([#425]) GitHub Actions: actions/checkout v5 . ([#423])","title":"Dependency Updates"},{"location":"Copper-Release-Notes/#v090-2025-07-31","text":"","title":"v0.9.0 - 2025-07-31"},{"location":"Copper-Release-Notes/#high-level_3","text":"This release is primarily driven by user requests. It introduces a full transform library (\u00e0 la tf2 for ROS), new keyframes in the logs, background tasks, a log checker, and a set of runtime and logging tuning parameters to better adapt to constrained environments.","title":"High Level"},{"location":"Copper-Release-Notes/#api-change","text":"The task API now uses finer-grained lifetimes for input and output types. This provides greater flexibility when testing tasks and was necessary to support the implementation of background tasks: Old API: impl<'cl> CuSrcTask<'cl> for FlippingSource { type Output = output_msg!('cl, RPGpioPayload); fn process(&mut self, clock: &RobotClock, output: Self::Output) -> CuResult<()> { self.state = !self.state; // Flip our internal state and send the message in our output. output.set_payload(RPGpioPayload { on: self.state, creation: Some(clock.now()).into(), actuation: Some(clock.now()).into(), }); Ok(()) } } There are two changes required to port your tasks: The lifetime has moved from <'cl> on the task struct to <'m> on the Input and Output types. The process method now takes explicit references: & for input and &mut for output. impl CuSrcTask for FlippingSource { type Output<'m> = output_msg!(RPGpioPayload); # ^^^^ fn process(&mut self, clock: &RobotClock, output: &mut Self::Output<'_>) -> CuResult<()> { # ^^^^ ^^^^ self.state = !self.state; // Flip our internal state and send the message in our output. output.set_payload(RPGpioPayload { on: self.state, creation: Some(clock.now()).into(), actuation: Some(clock.now()).into(), }); Ok(()) } }","title":"API Change"},{"location":"Copper-Release-Notes/#new-component-cu_transform","text":"The cu_transform crate provides real-time spatial and velocity transformations for Copper, with support for hierarchical frames, interpolation, and zero-allocation caching. Huge thank you to @makeecat for this feature!","title":"New Component: cu_transform"},{"location":"Copper-Release-Notes/#features","text":"Homogeneous matrix representation of 3D transforms Time-stamped pose updates and interpolated lookups Hierarchical transform tree with parent-child frames Velocity computation via transform differentiation Rigid-body velocity frame transformations High-performance caching for repeated transform/velocity queries Zero-allocation for real-time performance","title":"Features"},{"location":"Copper-Release-Notes/#example-pose-lookup","text":"use cu_transform::{StampedTransform, TransformTree, Transform3D}; use cu29::clock::CuDuration; let mut tree = TransformTree::<f32>::new(); tree.add_transform(StampedTransform { transform: Transform3D::default(), stamp: CuDuration(1000), parent_frame: \"world\".try_into()?, child_frame: \"robot\".try_into()?, })?; let pose = tree.lookup_transform(\"world\", \"robot\", CuDuration(1000))?;","title":"Example: Pose Lookup"},{"location":"Copper-Release-Notes/#example-velocity-lookup","text":"use cu_transform::TransformTree; use cu29::clock::CuDuration; let velocity = tree.lookup_velocity(\"world\", \"robot\", CuDuration(1500))?; let linear = velocity.linear_velocity(); let angular = velocity.angular_velocity(); This component is ideal for real-time robotic applications needing fast, correct spatial and motion reasoning across dynamic coordinate frames.","title":"Example: Velocity Lookup"},{"location":"Copper-Release-Notes/#new-features_3","text":"background tasks : we now have a best effort asynchronous task type. Be careful to use memory handles if you feed them a large amount of data has the input and output need to be copied to allow the asynchronism to work. How to use it? just add background: true to any CuTask (not Src nor Sink). ( tasks: [ ( id: \"task1\", type: \"tasks::ExampleTask\", background: true, // that's it ), ] The result will be set in a random future CopperList so for the downstream tasks keep a close eye on the input.tov field to know from where this message is coming from. Note: We have not implemented the deterministic replay yet for those, but it will come in an upcoming release. logreader fsck : we now have a cool tool to not only check for the consistency of a Copper log and giving you some explanation of any corruption, it gives out some cool statistics about the logs: pal \u279c cu_caterpillar (master) cargo run -r --bin cu-caterpillar-logreader logs/caterpillar.copper fsck The log checked out OK. === Statistics === Total time -> 1.481 s Total used size -> 14,120,984 bytes Logging rate -> 9.09 MiB/s (effective) # of CL -> 20,303 CL rate -> 13,708.96 Hz CL total size -> 10,384,994 bytes # of Keyframes -> 3 KF rate -> 2.03 Hz KF total size -> 28 bytes # of SL entries -> 162,433 SL total size -> 3,735,962 bytes Added a runtime rate target configuration (#410): Copper can be too fast, especially with the introduction of background tasks. We added a way to rate limit the CopperList creation, exactly like a frame rate limiter would work in games because probably your robot doesn't need 500KHz refresh rates normal use cases. For example limit at 100Hz: ( runtime: ( rate_target_hz: 100, ), tasks: [ Adds a way to disable logging for some tasks. (#407) With the determinism built in Copper, you might not want to log everything. We added a way to disable the logging of any task output. It will keep the metadata of the output though (Time of Validity, Status string ....) tasks: [ ( // Normal id: \"task0\", type: \"tasks::ExampleSrc\", ), ( id: \"task1\", type: \"tasks::ExampleTask\", logging: ( enabled: false, // HERE, no more logging for this one ) ), Keyframes (#369): Now Copper is able to record \"keyframe\" ie. the serialized state of all the tasks during runtime, sim or resim. This will allow nifty debugger features. force Serialize implementation on CuMsg : This guarantees that the log reader can at least reexport the messages to all the SerDe backends. cu-dorabench : a new benchmark more geared toward bandwith more than just latency.","title":"New Features"},{"location":"Copper-Release-Notes/#enhancements_2","text":"CuStampData : a lot of robotics data needs to be timestamped and this is also true for the CuMsg between tasks. We have generalized this concept so you can use a contained with a time of validity and arbitrary metadata for your own internal use in your tasks and libraries. // CuMsg is now defined as type CuMsg<P> = CuStampData<P, CuMsgMetadata>; // And now TOV (the time of validity for this temporal data) is directly accessible in the main object instead of the metadata let mut m: CuMsg<u32> = CuMsg::new(12); m.tov = CuDuration(1000).into(); // You can define temporal data types for yourself for example type MyTemporalData = CuStampData<f64, ()>; // And use them directly as a field in your tasks. resim implemented for cu-caterpillar (#364): added that to our venerable example to test out various logger features easily. cargo cubuild (#365): helps you debug when a change causes a code compilation error in the generated code. Just use that instead of build and it will insert the generated code at the macros spot and compile it. CuCompactString : Better log and debug output showing the string nicely.","title":"Enhancements"},{"location":"Copper-Release-Notes/#bug-fixes_2","text":"Unified Logger Poisoned lock (#390): We had a cascading error when the main thread would panic and drop the logger. Task DAG in the Monitoring UI is slow (#391): Thanks to Matthew Ashton-Knochel from working with tui-nodes folks to optimise the direct rendering mode of it. Restored the original log debug behavior (#381): if nothing is specified -> debug builds enable log-debug, -> release buids enable log-info. if anything is specified, it will repect the user's choice. Unconditionally install ctrl-c handler (#375): instead of relying on user's code to handle that as it can cause easy log corruption. Fix CuCompactString initialization CuListsManager (#409): a zero init of the copper list created status strings that are all 24x \\\\0 . This fixes it with a correct initialzation that set them at length 0 instead. It was wasting a bunch of log space for no reason.","title":"Bug fixes"},{"location":"Copper-Release-Notes/#dependency-updates_1","text":"socket2 -> 0.6.0 cuda-toolkit -> 0.2.26 gstreamer & gstreamer-app -> 0.24 rerun -> 0.24 glam -> 0.30.x thiserror -> 2.x","title":"Dependency updates"},{"location":"Copper-Release-Notes/#v080-2025-05-26","text":"","title":"v0.8.0 - 2025-05-26"},{"location":"Copper-Release-Notes/#high-level_4","text":"This release has been focused on Zenoh and ROS2 interoperability, modular configuration for larger robots with a new support for the notion of \"mission\" (aka mode like autonomy mode, datacollect mode etc..)","title":"High level"},{"location":"Copper-Release-Notes/#new-features_4","text":"Copper to ROS2 Integration : We now support streaming Copper data directly to ROS2 (rwm_zenoh). This includes a working example bridging Copper tasks to ROS2 nodes and a translation layer for Copper message representations. See PR #348 . Zenoh Sink : Added a zenoh_sink component to forward Copper messages to any other Zenoh participant with the serialization of your choice. Thanks to @kamibo ( #316 ). Missions System : You can now define and generate missions from RON, with automatic default fallback. Missions are properly serialized, structured, and support reuse through includes. ( #337 , #294 ) Modular Configuration System : Copper now supports reusable and parameterized config files. This feature introduces relative/absolute file includes, parameter substitution using {{param}} syntax, and well-defined merging rules. You can now split large config files into logical components and reuse templates with different parameters. Example templates are included under the modular_config_example directory. Thanks to @makeecat ( #328 ) Memory Pool Monitoring UI : Copper's monitoring console cu-consolemon now includes a dedicated page to visualize memory pool usage in real time. It displays total preallocated memory, in-use buffers, memory handles in flight, and the allocation rate. This provides better observability into buffer-heavy pipelines using CopperLists and memory pools. Thanks to @makeecat for implementing this! ( #190 ) CuRateLimit Task : A new CuRateLimit task lets you easily throttle any message flow without modifying the producing task. See #343 . Copper Application Trait : Introduced a trait to generalize Copper applications. Enables grouping and dynamic handling of mission-defined applications. ( #345 ) Nix Setup : Introduced Nix setup for Linux, supporting CUDA / non-CUDA environment. Thanks to @makeecat ! ( #332 )","title":"New Features"},{"location":"Copper-Release-Notes/#enhancements_3","text":"Compile-time log-level macro : Copper now supports compile-time log filtering for logs. This feature lets you fully disable logging macros at compile time by enabling only the relevant features in Cargo.toml . It introduces a log-level field in CuLogEntry , and updates serialization, formatting, and documentation accordingly. Thanks to @makeecat ! ( #318 ) Example usage: [dependencies] cu29 = { version = \"0.7.0\", features = [\"log-level-debug\"] } CuGraph Separation : Graph-related functionality has been extracted into its own module to reduce coupling between configuration and execution layers. ( #334 ) Bevy 0.16 Support : Copper is now compatible with Bevy 0.16, including updated patches for asset loading and avian3d. Thanks to @makeecat ( #303 ). Support for iceoryx2 v0.6.1 : Iceoryx2 backend updated and patched accordingly. ( #338 ) Dockerization of ros-caterpillar : ros-caterpillar has been fully containerized to deal with OS dependency hell. It is now portable and future-proof. ( #348 )","title":"Enhancements"},{"location":"Copper-Release-Notes/#dependency-bumps","text":"iceoryx2-bb-log bumped to 0.6.1 ( #340 ) uom bumped to 0.37.0 ( #339 ) Other crates : cached-path , iyes_perf_ui , faer , ron , petgraph , nix , etc. updated to support Bevy 0.16 and latest Rust editions.","title":"Dependency Bumps"},{"location":"Copper-Release-Notes/#v070-2025-03-14","text":"","title":"v0.7.0 - 2025-03-14"},{"location":"Copper-Release-Notes/#high-level_5","text":"This release added a set of feature useful to develop autonomy algorithms on Drone (MSP). We also have a solid set of quality of life improvements derived from real usage.","title":"High level"},{"location":"Copper-Release-Notes/#notable-regression","text":"bincode after 4 years stuck at the 2.0.0-rc3 decided to release the 2.0.0 and it broke the API. This release updates all our API calls. The good news is that decoding in memory pools are now supported, it will be useful.","title":"Notable regression"},{"location":"Copper-Release-Notes/#new-features_5","text":"gstreamer support You can define arbitraty gstreamer pipeline and hook it as an appsink to Copper are a SrcTask [#239] This for example a source that will get the camera from your robot, stream it to a host on your network for live display but also convert it to GRAY8 and inject it to the Copper task graph. ( id: \"video\", type: \"cu_gstreamer::CuDefaultGStreamer\", config: { \"pipeline\": \"v4l2src device=/dev/video9 ! image/jpeg,width=1920,height=1080 ! tee name=t t. ! queue ! jpegdec ! videoconvert ! appsink name=copper t. ! queue ! jpegparse ! rtpjpegpay ! udpsink host=192.168.1.73 port=5000\", \"caps\": \"video/x-raw, format=GRAY8, width=1920, height=1080\", }, ), Dynamic Threshold . A quick 0 copy implementation using an integral image. [#244] April Tag support . It can give you the relative pose of tags from images. [#246] ( id: \"pos\", type: \"cu_apriltag::AprilTags\", config: { \"tag_family\": \"tag16h5\", \"tag_size\": 0.14, \"fx\": 1513.93, \"fy\": 1513.93, \"cx\": 946.84, \"cy\": 557.819, }, ), MSP (MultiWii Serial Protocol) This is a communication protocol used on drones with INAV, cleanflight, betafligh [#248] Added 2 new robotics standard messages: Transform3D and Pose [#245] They can be transformed back and forth with into() from Faer and Nalgebra so you can integrate that to your robotics algorithms smoothly. let pose = Transform3D { mat: [ [1.0, 2.0, 3.0, 4.0], [5.0, 6.0, 7.0, 8.0], [9.0, 10.0, 11.0, 12.0], [13.0, 14.0, 15.0, 16.0], ], };","title":"New Features"},{"location":"Copper-Release-Notes/#quality-of-life-improvements","text":"The Cu29 crate has a new global debug_macro feature to be able to see any generation (runtime, structured logging, SOAs etc...) [#247] PyO3 (the python bindings for log reading) is now an optional feature [#240] Thanks Mike Kaliman! The Input order in the tuples of tasks receiving messages from more than one taask is now determined by their order of connection [#251] Thanks @hscoelho ! Better feedback when a task sends an error to the runtime. Ie. now it actually triggers a debug! with the error description instead of just giving you the result of the monitoring behavior. CuTime now support Copy which makes clock forwarding more immediate. Bevy perf-ui is back (overlay for bevy) and can be used in your simulations (see cu-balancebot) [#263] Thanks @AS1100K ! And finally special thanks to @makeecat for the ongoing help on the CI/CD that starts to be a complicated piece of machinery at this point.","title":"Quality of life improvements"},{"location":"Copper-Release-Notes/#v060-2025-01-20","text":"","title":"v0.6.0 - 2025-01-20"},{"location":"Copper-Release-Notes/#new-features_6","text":"Images support : We added the API to make a pool instance and bind is as a [u8] for an image buffer, see below about Memory Pools. Video For Linux 2 support : We built a V4L2 source so you can read images directly from you video system on Linux. The component is named cu_v4l here are an example of parameters to can set in your RON file: config: { \"device\": 0, // The /dev/video0 device \"width\": 3840, // Width asked \"height\": 2160, // Height asked \"fps\": 30, // image rate \"fourcc\": \"NV12\", // buffer format \"buffers\": 4, // how many buffers you want to allocate \"timeout_ms\": 500, // time before giving up on trying to get a frame } https://github.com/user-attachments/assets/0858026d-bf92-418f-9525-3df5d5de9b70 Computer Vision: Kornia API support : Kornia is an awesome Computer Vision set of algorithms. The 2 projects cooperated to we can map Copper images to Kornia and Kornia can accept them with 0 copy! Check out the Kornia-rs project . Big thanks to the creator of this project Edgar Riba for his support! 0-Copy Heterogeneous Memory Pools : Said wut? Before this release anything the tasks would touch (as input or output) would have been needed to be copied in the CopperList ie. the backing structure that makes Copper so fast and low latency with no synchronization etc. Building a complex robot is the art of having not only low latency like this but also large throughput: this is the large throughput side of Copper for modern computer architectures! You can create large memory buffers pools either in main host memory or on a \"device\" for example a GPU (this is what heterogeneous memory means) and Copper will give you memory handles that you can use to: - pass the memory to another task - pass the memory to the accelerator that can use it (for example CUDA kernels see below) - pass the memory to a DMA backed driver (see the new V4L driver below) For you developer, it means that you can safely stream multi-megabytes structures (Images, Matrices, PointClouds etc..) at no cost and you also buffer them in tasks if you need to keep them for a few cycle more (for temporal alignment for example). New Basic Livox Lidar Tele15 Driver : Thanks to @luc-k1 from Konboi One. New Debug log pane in cu-consolemon : Before that you had to choose between the cool TUI and the text log (that was hidden behind) but thanks to @AS1100K effort we now have a tab that can capture your debug logs! (it is only enabled if you want them as they are expensive to build and if the app is build in debug mode). Pcap replay support : for drivers reading data from the network, it is very common to build a test set from network capture. This is a little tool that help driver developer to inject those capture and build a small test data set to validate their driver. Quicksort on PointCloud SOA ts : Sorting by time of validity allows the points to get merged more efficiently. 2 lidar sources getting merged.","title":"New Features"},{"location":"Copper-Release-Notes/#enhancements_4","text":"Prelude : we drastically simplified the imports for Copper, now you just need to do: use cu29::prelude::*; And you are good to go for starting Copper, creating tasks, etc... More flexible project generation : The template will ask you which version of Copper you want to generate your project for. Log parameter in RON : Added the section_size parameter in the RON file. It is useful to tune your logging throughput. Builder pattern for the Copper Application : we made the CopperContext official and change the app init to be with a cool builder pattern like: let mut application = CaterpillarApplicationBuilder::new() .with_context(&copper_ctx) .build() .expect(\"Failed to create application.\"); Thanks to @hscoelho for this one! Log disable : Now you can disable task logging completely (if you know you won't need the data). Thanks to @AS1100K ! Better feedback on configuration snafu : We improved the clarity of the messages given to the user with a line number if possible in case of misconfiguration... Thanks again to @AS1100K ! Full dependency update : Enjoy the latest Bevy, the latest Rerun, the latest everything thanks to @makeecat . This includes the new picker that has been integrated to Bevy. Logger Parameters Consistency : We now check if the various parameters of the unified logger makes sense ie. section not larger than slabs etc.. that avoids a lot of user confusion. Clippy escaped our CI/CD again but thanks to an heroic effort from @makeecat we have a major improvement on our CI/CD to cross check all the platforms, features and configurations. -= op on CuTime, it is useful to compute quickly time offsets. ScopedAllocCounter : we improved their use by exposing a sane public API so you can check if you or one of your dependency is allocating in a given scope. Thanks to Zac8668","title":"Enhancements"},{"location":"Copper-Release-Notes/#bug-fixes_3","text":"X11 support for Bevy on Linux : Apparently some people have not migrated to Wayland yet :P. Thanks @Paulotten Missing ./logs would make cu-balancebot-sim crash: thanks @vsenn for reporting this.","title":"Bug Fixes"},{"location":"Copper-Release-Notes/#v051-2024-12-05","text":"","title":"v0.5.1 - 2024-12-05"},{"location":"Copper-Release-Notes/#new-features_7","text":"Microsoft Windows Compatibility is finally complete #129 : So many thanks to @Lishen_ for the unwaivering bruteforce port. Rerun visualization for pointclouds #131 : Added an example to start and feed rerun visualization with our standard pointcloud","title":"New Features"},{"location":"Copper-Release-Notes/#enhancements_5","text":"BalanceBot Simulation perf overlay #137 : Now you can activate the perf-ui feature to see if the bevy side of the simulation is working well in a diag overlay. Iterators For SOAs (Struct of arrays) #134 : SOAs can generate an iterator for a quick SOA to AOS transform and natural API.","title":"Enhancements"},{"location":"Copper-Release-Notes/#bug-fixes_4","text":"BalanceBot Simulation Issues #137 : Resolved a waste of resources on balancebot-sim (the bevy entities were created over and over). Thanks to @Nashenas88 for spotting the issure and the initial fix. Pointcloud payload and Hesai structs visibility fix #132 & #133 : Snafu as they were published with no client crates. Multiple gammar fixes #125 : Thanks to @AnyTimeTraveler for all the corrected Frenglish.","title":"Bug Fixes"},{"location":"Copper-Release-Notes/#v050-2024-12-02","text":"","title":"v0.5.0 - 2024-12-02"},{"location":"Copper-Release-Notes/#new-features_8","text":"Deterministic Log Replay : Copper can now replay a log through your code in a deterministic fashion ie. if your tasks are deterministic, it will always output the same output from the same input! See the balancebot-resim for example. Aligner Task #114 : Added an aligner task that synchronizes multiple inputs by aligning matching time windows, facilitating coordinated data processing. This is particularly useful for sensor fusion. :exclamation: Lifecycle Trait Removal #115 : Removed the lifecycle trait to simplify task implementation and decouple passed types, streamlining the codebase. To build a minimum task a user needed to implement one method from the CuTaskLifecycle trait (new) and at least the process method from they flavor of tasks. This was forcing the implementation of 2 mandatory traits which is not necessary or useful for the user. Now we moved all the lifecycle methods in the tasks trait to only have to implement 2 traits (the task and Freezable, the serialization of its state)","title":"New Features"},{"location":"Copper-Release-Notes/#enhancements_6","text":"Named Output Mapping on CopperLists #121 : Implemented mapping of Copperlist indices to named outputs from tasks, allowing users to access task outputs symbolically without relying on execution order. CuTimeRange Introduction #106 : Introduced CuTimeRange to represent messages containing multiple Time of Validity (TOV) instances, such as sequences of images or IMU measurements. Windows Compatibility #110 : Enhanced compatibility by adding a mock for cu_ads7883 , enabling compilation on Windows platforms. Dependency Updates #104 : Performed a general dependency bump post-release to incorporate the latest improvements and fixes. Faster SOA ops : adding len to the public API allows quicker preallocations. f32 shortcut for dimensions and reflectivity for Lidars : simple from f32 makes it easier to not deal too much with the units.","title":"Enhancements"},{"location":"Copper-Release-Notes/#bug-fixes_5","text":"BalanceBot Simulation Stability #118 : Resolved a core dump issue on exit for balancebot-sim by enforcing specific graphics backends, ensuring clean termination. CuCompactStr Serialization #119 : Fixed serialization and deserialization issues with CuCompactStr to ensure correct data handling. Project Generation Fix #120 : Addressed issues in project generation by adding crate:: for cumsgs generation, ensuring correct module resolution. Unused Code Cleanup #121 : Removed unused imports and methods to maintain code cleanliness and reduce potential maintenance overhead. Test Stability #107 : Ignored hardware-dependent tests and added test --workspace to CI/CD to enhance test reliability across different environments.","title":"Bug Fixes"},{"location":"Copper-Release-Notes/#v041-2024-11-15","text":"","title":"v0.4.1 - 2024-11-15"},{"location":"Copper-Release-Notes/#new-features_9","text":"Iceoryx2 Support #87 : Introduced Iceoryx2 support. Iceoryx2 is the successor to Iceoryx in pure Rust. The Copper support included a source component to receive messages, a sink component to send messages. Hesai XT32 Support #101 : Added the preliminary support for the Hesai XT32. If you have the actual HW handy, feel free to provide us the feedback! First standard Lidar Message Design #99 : For now in SOA out or the lidar sensors it allows SIMD optimizations for the first operations that are usually a frame transform.","title":"New Features"},{"location":"Copper-Release-Notes/#enhancements_7","text":"Variable-Length SoAs #100 : Improved SoA (Structure of Arrays) to support variable lengths on top of their fixed size in the Copper List. CI Improvements #98 : Integrated clippy warnings into CI, thanks to makeecat","title":"Enhancements"},{"location":"Copper-Release-Notes/#bug-fixes_6","text":"BalanceBot Simulation Reset #86 : Improved the reset_sim functionality for the balance bot. Thanks to makeecat . Publishing Fixes #103 : Resolved various publishing issues and added dry-run validations to avoid disruptions.","title":"Bug Fixes"},{"location":"Copper-Release-Notes/#v040-2024-10-29","text":"","title":"v0.4.0 - 2024-10-29"},{"location":"Copper-Release-Notes/#new-features_10","text":"Simulation API Support : With sim-mode=true in the main Copper macro, Copper will generate for you all the callbacks at all the tasks states it is going through (Start, Preprocess, Process, etc...). Combined with the already mockable Clock it allows a very easy integration with a virtual environment. BalanceBot Simulation #69 : Built on that and leveraging Bevy and Avian3D for realistic motion dynamics, we made a little demo of our little real world demonstrator. The real world code and the sim code are 100% identical. Config Embedding #78 : Embedded the default copperconfig.ron directly into the Copper executable, simplifying deployment for the main case (just one executable to copy and that's it!!). If the file is present, it will take precedence over the embedded version. We also do log the actual config used in the logs so you can come back to it in doubt.","title":"New Features"},{"location":"Copper-Release-Notes/#enhancements_8","text":"Cross-Platform Compatibility for Mocking #75 : Enhanced feature flags to better support various platforms, particularly macOS, enabling testing with mocked hardware dependencies. The full repo now compile under CI/CD on MacOS and Linux (previously it we could only compile and test the Core)","title":"Enhancements"},{"location":"Copper-Release-Notes/#bug-fixes_7","text":"Terminal Restoration #73 : Fixed issues with terminal states not restoring properly upon exit, preventing corruption and enhancing the overall stability of simulator sessions. Print Output Cleanup #80 : Streamlined console logging to minimize redundant or unnecessary print statements, making debugging output more manageable. Git LFS Migration #76 : Moved heavy assets to a CDN to mitigate GitHub LFS limitations, reducing operational overhead and streamlining asset distribution.","title":"Bug Fixes"},{"location":"Copper-Release-Notes/#infrastructure-and-cicd","text":"Asset CDN Integration #35 : Transitioned assets to a content delivery network to avoid the super costly Github LFS. Improved Documentation #82 : Expanded and refined documentation across modules, enhancing clarity for new users and developers.","title":"Infrastructure and CI/CD"},{"location":"Copper-Release-Notes/#internal-refactoring","text":"Logging Value Enhancements #80 : Fine-tuned value logging to increase logging granularity and simplify troubleshooting in complex simulation states. Feature Flag Revamp #75 : Restructured feature flags to better support debugging and cross-platform configurations, especially for macOS compatibility.","title":"Internal Refactoring"},{"location":"Copper-Release-Notes/#v031-2024-10-12","text":"A Minor release with 2 new components and some fixes.","title":"v0.3.1 - 2024-10-12"},{"location":"Copper-Release-Notes/#new-components","text":"New cu-pid task: this is the first algorithm we publish. It is from the balancebot, a generalized PID controller logic you can reuse in your projects, see the readme in the crate. New cu-consolemon monitoring: this is a TUI for Copper showing the information exposed by the new monitoring interface released in 0.3.0.","title":"New Components"},{"location":"Copper-Release-Notes/#api-improvements","text":"Added Mul to CuDuration for easy time offset computations.","title":"API improvements"},{"location":"Copper-Release-Notes/#various","text":"Tree Reorganization : Major reorganization of the repository structure for improved clarity and maintainability.","title":"Various"},{"location":"Copper-Release-Notes/#bug-fixes_8","text":"Logging Fixes : Resolved an issue where OnceLock was not releasing the unified logger, preventing a clean shutdown of the logger. Addressed an issue with a double close in the logger during shutdown.","title":"Bug Fixes"},{"location":"Copper-Release-Notes/#v030-2024-09-30","text":"This alpha release introduces substantial improvements to the Copper framework's monitoring capabilities and API flexibility.","title":"v0.3.0 - 2024-09-30"},{"location":"Copper-Release-Notes/#highlights","text":"New multisource and optional input API : The Copper engine now supports multiple and optional inputs/outputs (see PR #44). This is a breaking change . Now you can link 2 tasks to one in the RON file like this: tasks: [ ( id: \"balpos\", type: \"cu_ads7883::ADS7883\", ), ( id: \"railpos\", type: \"cu_rp_encoder::Encoder\", ), ( id: \"pidctrl\", type: \"pidtask::PIDTask\", config: { [...] }, ), ( id: \"motor\", type: \"cu_rp_sn754410::SN754410\", [...] ), ], cnx: [ // vvvvvvvvvv same dest! (src: \"balpos\", dst: \"pidctrl\", msg: \"cu_ads7883::ADSReadingPayload\"), (src: \"railpos\", dst: \"pidctrl\", msg: \"cu_rp_encoder::EncoderPayload\"), (src: \"pidctrl\", dst: \"motor\", msg: \"cu_rp_sn754410::MotorPayload\"), ], ) To help you manage the types that are generated, we are giving a set of macros to help you matching the correct input / output types: impl<'cl> CuTask<'cl> for PIDTask { // This tasks takes 2 inputs! // They are given in the order of task declaration // the input_msg! macro build a (&CuMsg<ADSReadingPayload>, &CuMsg<EncoderPayload>) tuple under the hood. // it also works with 1 input and then you will get a straight &CuMsg<> immutable ref. // For technical Rust reasons, you need to explicitely tie the lifetime ('cl means copperlist if you are curious: the internal structure of copper for messages) type Input = input_msg!('cl, ADSReadingPayload, EncoderPayload); // same thing but as an output this is a &mut CuMsg<MotorPayload> type Output = output_msg!('cl, MotorPayload); fn process( &mut self, clock: &RobotClock, input: Self::Input, // here this is now straight the input type, it is a little simpler. output: Self::Output, ) -> CuResult<()> { let (bal_pos, rail_pos) = input; // you can unpack the tuple directly those are resp. &CuMsg<ADSReadingPayload> and &CuMsg<EncoderPayload> let bal_tov = bal_pos.metadata.tov.expect(\"we should have had a message here!\"); // the messages are now optional depending on the context they could be expected or really optional. // we have a new method called set_payload for the output output.set_payload(MotorPayload { power: 0.0 }); // If you don't do that it will send away a message with a None payload Monitoring System : The monitoring framework is now fully integrated, allowing real-time stats collection and cumulative statistics (see PRs #49, #50, and #51). We can imagine complex decision trees happening at that stage for complex robots and various degraded modes. The monitoring component is really similar to a task, but with specialized callbacks: // This is in the RON file, just add a monitor entry like this: tasks: [ ( id: \"task0\", type: \"tasks::ExampleSrc\", ), [...] ], cnx: [ (src: \"task0\", dst: \"task1\", msg: \"i32\"), [...] ], monitor: (type: \"ExampleMonitor\") // here, add a config entry if necessary ) struct ExampleMonitor { tasks: &'static [&'static str], // We give you the task ordinal to task id mapping (so it is stable as long as you don't change your task ids. } impl CuMonitor for ExampleMonitor { // We pass you the config you gave in the RON file exactly like for the tasks. fn new(_config: Option<&ComponentConfig>, taskids: &'static [&str]) -> CuResult<Self> { Ok(ExampleMonitor { tasks: taskids }) } fn start(&mut self, clock: &_RobotClock) -> CuResult<()> { // callbacked when all the tasks, start called. } fn process_copperlist(&self, msgs: &[&CuMsgMetadata]) -> CuResult<()> { // This is callbacked at the end of the processing of a copper list (basically near when the CL is getting serialized to disk after a success. // The metadata gives you all the timings you need to check if your robot is still behaving nominally. for t in msgs.iter().enumerate() { let (taskid, metadata) = t; debug!(\"Task: {} -> {}\", taskid, metadata); } Ok(()) } fn process_error(&self, taskid: usize, step: CuTaskState, error: &CuError) -> Decision { // This is called back if any task reports an error at any step (start, process, ...) // You can then match that taskid and compute a decision for your robot: Abort, Ignore, Shutdown (see the cu28/monitoring.rs file for semantic details. Decision::Ignore } fn stop(&mut self, clock: &_RobotClock) -> CuResult<()> { // call when the stack is stopping Ok(()) } }","title":"Highlights"},{"location":"Copper-Release-Notes/#other-notable-changes","text":"","title":"Other Notable Changes"},{"location":"Copper-Release-Notes/#new-features_11","text":"Real-time cumulative stats for CuDurations . See cu29/monitoring.rs we built an histogramming feature for timings this is super useful for monitoring components. Here is the list of everything you get it is not only pretty comprehensive but it is fixed size on memory so it should be pretty swift for any real time monitoring needs or UIs. // on the CuDurationStatistics struct pub fn min(&self) -> CuDuration; pub fn max(&self) -> CuDuration; pub fn mean(&self) -> CuDuration pub fn percentile(&self, percentile: f64) -> CuDuration; pub fn stddev(&self) -> CuDuration; pub fn jitter_min(&self) -> CuDuration; pub fn jitter_max(&self) -> CuDuration; pub fn jitter_mean(&self) -> CuDuration; pub fn jitter_stddev(&self) -> CuDuration; pub fn jitter_percentile(&self, percentile: f64) -> CuDuration;","title":"New Features"},{"location":"Copper-Release-Notes/#fixes","text":"Serialization / Deserialization Bug on Value (#42). A code reformat shuffled the serialization IDs Oo.","title":"Fixes"},{"location":"Copper-Release-Notes/#enhancements_9","text":"Virtual Output for Sinks (#53): before that there was no mean to monitor sinks (or hacks you might have seen on the incoming message). Now the stack behind the scene generates a () empty message for each sink you you get the perf number cleanly for them even if they don't output anything. Balance Bot Demo (#46): a more complete example of a real robot demo we will bring at conferences.","title":"Enhancements"},{"location":"Copper-Release-Notes/#miscellaneous","text":"And a bunch of cleanup / doc improments.","title":"Miscellaneous"},{"location":"Copper-Release-Notes/#copper-v023-2024-09-11","text":"We are pleased to announce the release of Copper v0.2.3, which includes several new features, enhancements, and bug fixes. Below is a summary of the key changes in this release:","title":"Copper - v0.2.3 - 2024-09-11"},{"location":"Copper-Release-Notes/#new-features_12","text":"SN754410 Driver Support #40 : Added a new driver for the SN754410 motor driver. This driver allows easy integration with motor control applications, providing robust support for H-bridge motor control on a wide range of systems. This driver is fully compatible with the BalanceHAT. ADS7883 Driver #39 : Introduced a driver for the ADS7883, a 12-bit SPI ADC. This addition includes comprehensive documentation in the README to facilitate setup and integration. The ADS7883 driver is also compatible with the BalanceHAT.","title":"New Features"},{"location":"Copper-Release-Notes/#enhancements_10","text":"macOS Development Support #25 : Copper can now be developed on macOS! The CI/CD pipeline has been updated to support macOS, ensuring cross-platform compatibility for all users. cu29_clock Enhancements #32 : Added a division feature to the cu29_clock, allowing more granular time management and synchronization within the Copper runtime. Structured Log Index File in Debug Mode #30 : Removed the requirement for an index file in debug mode within struct_log, simplifying the debugging process ie. only the config and the executable needs to be deployed for the debug build and you get a standard debug text logging. Logging Slabs Addition #24 : The current unified logger works with big memory mapped files. Initially we thought we could rely on the mmap resize feature of the kernel api but it just doesn't work. We are reverting into building \"slabs\", ie dividing the data logger into large files. Those files can be concatenated and read or directly read from the log exporter.","title":"Enhancements"},{"location":"Copper-Release-Notes/#bug-fixes_9","text":"Compilation Feedback Adjustments #33 : Moved compilation feedback from standard output to standard error to better align with conventional logging practices. Flush and Core Dump Fixes #29 : Resolved issues where changes after a section flush could cause a core dump, improving the stability of the logging system.","title":"Bug Fixes"},{"location":"Copper-Release-Notes/#infrastructure-and-cicd_1","text":"CI/CD Pipeline Enhancements #25 : Added macOS support to the CI/CD pipeline, ensuring better cross-platform compatibility. Removed 'Continue on Error' in CI/CD #36 : Addressed a CI/CD issue where the pipeline was green while failing Oo.","title":"Infrastructure and CI/CD"},{"location":"Copper-Release-Notes/#refactoring-and-internal-changes","text":"Unified Logger Refactor #27 : Refactored the Unified Logger to introduce a dual-slab logging system, improving performance and eliminating the need for remap/resize operations. Runtime Loop Enhancements #21 : Added a new notion of loops in the runtime plan, setting the stage for more flexible and powerful runtime behavior. If you're looking to build your own interfacing with the SN754410 or ADS7883 drivers, we share detailed connectivity schematics with a Raspberry Pi to help you get started. We recommend updating to this latest version to take advantage of these improvements. As always, please refer to the updated documentation and release notes for detailed information on how to integrate these changes into your projects. If you have any questions or need further assistance, feel free to reach out to our support team.","title":"Refactoring and Internal Changes"},{"location":"Copper-Runtime-Overview/","text":"Copper Runtime Overview \u00b6 Copper is a deterministic, data-oriented runtime for robotics. You describe your system declaratively, Copper compiles the schedule, and every run is bit-for-bit reproducible. Task Graph \u00b6 The task graph defines your system topology, inter-task communication, and message types. It is expressed in RON and drives how Copper builds the runtime. See Copper RON Configuration Reference for the full schema. Runtime Generator \u00b6 Copper creates an execution plan from the task graph metadata. It preallocates a \"Copper List\" so execution stays cache-friendly and deterministic. Zero-Copy Data Logging \u00b6 Messages between tasks are recorded without copying data. Logs can be replayed exactly, making debugging and certification practical. Fast Structured Logging \u00b6 Structured log strings are interned and indexed at compile time. Runtime logging avoids string construction overhead and keeps hot paths fast. SDK Capabilities \u00b6 Task interface and lifecycle traits for implementing new algorithms, sensors, and actuators. Compile-time runtime generation with deterministic scheduling. Log readers that export Copper logs using Rust Serde formats. Structured log reader for efficient debug and telemetry data. A growing set of components and drivers (see Available Components ). Deterministic log replay and resimulation. A minimal simulation environment for hardware-free testing.","title":"Copper Runtime Overview"},{"location":"Copper-Runtime-Overview/#copper-runtime-overview","text":"Copper is a deterministic, data-oriented runtime for robotics. You describe your system declaratively, Copper compiles the schedule, and every run is bit-for-bit reproducible.","title":"Copper Runtime Overview"},{"location":"Copper-Runtime-Overview/#task-graph","text":"The task graph defines your system topology, inter-task communication, and message types. It is expressed in RON and drives how Copper builds the runtime. See Copper RON Configuration Reference for the full schema.","title":"Task Graph"},{"location":"Copper-Runtime-Overview/#runtime-generator","text":"Copper creates an execution plan from the task graph metadata. It preallocates a \"Copper List\" so execution stays cache-friendly and deterministic.","title":"Runtime Generator"},{"location":"Copper-Runtime-Overview/#zero-copy-data-logging","text":"Messages between tasks are recorded without copying data. Logs can be replayed exactly, making debugging and certification practical.","title":"Zero-Copy Data Logging"},{"location":"Copper-Runtime-Overview/#fast-structured-logging","text":"Structured log strings are interned and indexed at compile time. Runtime logging avoids string construction overhead and keeps hot paths fast.","title":"Fast Structured Logging"},{"location":"Copper-Runtime-Overview/#sdk-capabilities","text":"Task interface and lifecycle traits for implementing new algorithms, sensors, and actuators. Compile-time runtime generation with deterministic scheduling. Log readers that export Copper logs using Rust Serde formats. Structured log reader for efficient debug and telemetry data. A growing set of components and drivers (see Available Components ). Deterministic log replay and resimulation. A minimal simulation environment for hardware-free testing.","title":"SDK Capabilities"},{"location":"CuBridge-Concept/","text":"## What bridges are (and why) A bridge lets Copper talk to an external transport (serial, CAN, DDS, middleware, ESC bus\u2026) through multiple logical channels that share the same connection. Each channel has a typed payload and a direction: Tx (Copper \u2192 outside) or Rx (outside \u2192 Copper). Types are enforced at compile time, so you don\u2019t accidentally mix payloads. Missions can override transport routes/topics/paths per channel without changing code (e.g., switch topics per robot or per mission). Defining channels and the bridge \u00b6 Declare Tx/Rx channels with the tx_channels! / rx_channels! macros. You give each channel: an ID (used in the mission file to connect), a payload type, an optional default route/topic/path (used if the mission doesn\u2019t override it). Implement CuBridge: Specify which channel sets are Tx/Rx. new receives bridge-level config plus per-channel configs (including any mission route overrides) so you can set baud, QoS, topic names, etc. receive fills a CuMsg for the selected Rx channel; send consumes a CuMsg for a Tx channel. Optional hooks: start (before first I/O), preprocess/postprocess per iteration, stop at shutdown. Use them to open sockets/ports, prefill buffers, flush, or close. Wiring in a mission \u00b6 In the mission config, add a bridges entry with an ID, the Rust type, optional config, and the list of channels (Rx/Tx). You can override any channel\u2019s default route here. Connect graph edges by using bridge_id/channel_id in cnx. Direction is enforced: Rx can only be a source endpoint; Tx can only be a destination endpoint. ## Scheduling: when bridge methods run Lifecycle: start runs with task starts; stop runs with task stops. preprocess/postprocess bracket each iteration like tasks do. Per-iteration order: Rx channels behave like sources: receive is called before any tasks that consume that channel\u2019s output. Tx channels behave like sinks: send is called after the upstream task(s) that feed that channel have run. If a bridge has both Rx and Tx used in the same dataflow, the runtime linearizes them: Rx \u2192 tasks \u2192 Tx on that bridge, preserving dependencies. Unconnected channels: If an Rx channel is never connected, its receive is never called. If a Tx channel is never connected, its send is never called. Idle channels still see start/stop (the bridge instance exists), so keep those cheap. Routes and overrides \u00b6 Default routes set in macros are just suggestions. Missions can override per channel. At runtime, use the provided BridgeChannelConfig to pick \u201ceffective\u201d routes; it already merges defaults and overrides. Config blocks per channel are also passed in, so you can tweak QoS, IDs, baud rates, etc., without recompiling. When to use a bridge vs. plain sources/sinks \u00b6 Use a bridge when multiple channels share the same transport or need shared state (one serial port, one CAN bus, one Zenoh session, multiple ESCs on one bus). Use plain CuSrcTask/CuSinkTask when each endpoint is independent hardware or logic and doesn\u2019t need shared transport management. Practical patterns \u00b6 Single transport, many outputs: e.g., one ESC bus bridge with four Tx channels, each an ESC command; four Rx channels for telemetry. Tasks feed/consume those channels; ports/QoS live in bridge config. Telemetry uplink/downlink: one middleware bridge with Rx for inbound commands and Tx for outbound telemetry; routes are swapped per mission (sim vs. robot).","title":"Copper Bridge concept"},{"location":"CuBridge-Concept/#defining-channels-and-the-bridge","text":"Declare Tx/Rx channels with the tx_channels! / rx_channels! macros. You give each channel: an ID (used in the mission file to connect), a payload type, an optional default route/topic/path (used if the mission doesn\u2019t override it). Implement CuBridge: Specify which channel sets are Tx/Rx. new receives bridge-level config plus per-channel configs (including any mission route overrides) so you can set baud, QoS, topic names, etc. receive fills a CuMsg for the selected Rx channel; send consumes a CuMsg for a Tx channel. Optional hooks: start (before first I/O), preprocess/postprocess per iteration, stop at shutdown. Use them to open sockets/ports, prefill buffers, flush, or close.","title":"Defining channels and the bridge"},{"location":"CuBridge-Concept/#wiring-in-a-mission","text":"In the mission config, add a bridges entry with an ID, the Rust type, optional config, and the list of channels (Rx/Tx). You can override any channel\u2019s default route here. Connect graph edges by using bridge_id/channel_id in cnx. Direction is enforced: Rx can only be a source endpoint; Tx can only be a destination endpoint. ## Scheduling: when bridge methods run Lifecycle: start runs with task starts; stop runs with task stops. preprocess/postprocess bracket each iteration like tasks do. Per-iteration order: Rx channels behave like sources: receive is called before any tasks that consume that channel\u2019s output. Tx channels behave like sinks: send is called after the upstream task(s) that feed that channel have run. If a bridge has both Rx and Tx used in the same dataflow, the runtime linearizes them: Rx \u2192 tasks \u2192 Tx on that bridge, preserving dependencies. Unconnected channels: If an Rx channel is never connected, its receive is never called. If a Tx channel is never connected, its send is never called. Idle channels still see start/stop (the bridge instance exists), so keep those cheap.","title":"Wiring in a mission"},{"location":"CuBridge-Concept/#routes-and-overrides","text":"Default routes set in macros are just suggestions. Missions can override per channel. At runtime, use the provided BridgeChannelConfig to pick \u201ceffective\u201d routes; it already merges defaults and overrides. Config blocks per channel are also passed in, so you can tweak QoS, IDs, baud rates, etc., without recompiling.","title":"Routes and overrides"},{"location":"CuBridge-Concept/#when-to-use-a-bridge-vs-plain-sourcessinks","text":"Use a bridge when multiple channels share the same transport or need shared state (one serial port, one CAN bus, one Zenoh session, multiple ESCs on one bus). Use plain CuSrcTask/CuSinkTask when each endpoint is independent hardware or logic and doesn\u2019t need shared transport management.","title":"When to use a bridge vs. plain sources/sinks"},{"location":"CuBridge-Concept/#practical-patterns","text":"Single transport, many outputs: e.g., one ESC bus bridge with four Tx channels, each an ESC command; four Rx channels for telemetry. Tasks feed/consume those channels; ports/QoS live in bridge config. Telemetry uplink/downlink: one middleware bridge with Rx for inbound commands and Tx for outbound telemetry; routes are swapped per mission (sim vs. robot).","title":"Practical patterns"},{"location":"FAQ/","text":"FAQ \u00b6 How is Copper better or different from the ROS (Robot Operating System)? \u00b6 Copper is a user-friendly runtime engine written in Rust. It manages task execution, data flow, logging, and deterministic replay. ROS is an open-source set of software libraries and tools primarily written for C++ and Python. Is it that more performant? \u00b6 In the example directory, there are two equivalent applications: one written in C++ for ROS and a port in Rust with Copper. examples/cu_caterpillar examples/ros_caterpillar You can run them on a desktop or with GPIOs on a Raspberry Pi. You should see an order-of-magnitude difference in performance. Copper is designed for performance first, using a data-oriented approach to minimize latency and maximize throughput. What about safety considerations? \u00b6 Copper is fully deterministic, which means you can replay captured data and get the same results you observed on the robot. Copper is written in Rust, so it is memory safe and thread safe by design.","title":"FAQ"},{"location":"FAQ/#faq","text":"","title":"FAQ"},{"location":"FAQ/#how-is-copper-better-or-different-from-the-ros-robot-operating-system","text":"Copper is a user-friendly runtime engine written in Rust. It manages task execution, data flow, logging, and deterministic replay. ROS is an open-source set of software libraries and tools primarily written for C++ and Python.","title":"How is Copper better or different from the ROS (Robot Operating System)?"},{"location":"FAQ/#is-it-that-more-performant","text":"In the example directory, there are two equivalent applications: one written in C++ for ROS and a port in Rust with Copper. examples/cu_caterpillar examples/ros_caterpillar You can run them on a desktop or with GPIOs on a Raspberry Pi. You should see an order-of-magnitude difference in performance. Copper is designed for performance first, using a data-oriented approach to minimize latency and maximize throughput.","title":"Is it that more performant?"},{"location":"FAQ/#what-about-safety-considerations","text":"Copper is fully deterministic, which means you can replay captured data and get the same results you observed on the robot. Copper is written in Rust, so it is memory safe and thread safe by design.","title":"What about safety considerations?"},{"location":"Modular-Configuration/","text":"Copper's configuration system supports modular composition through file includes and parameter substitution. This document explains how to use these features to create reusable and maintainable configuration files. Table of Contents \u00b6 Overview Including Configuration Files Parameter Substitution Merging Rules Nested Includes Common Use Cases Best Practices Limitations Examples Overview \u00b6 As robot configurations grow more complex, it becomes important to organize and reuse configuration components. Copper's modular configuration system allows you to: Split large configurations into manageable, reusable chunks Create configuration variations without duplicating the entire RON file Parameterize configurations to handle different deployments and environments Including Configuration Files \u00b6 You can include other RON configuration files using the includes section at the top level of your configuration: ( tasks: [ // Your main configuration tasks... ], cnx: [ // Your main configuration connections... ], includes: [ ( path: \"path/to/included_config.ron\", params: {}, // Optional parameter substitutions ), ], ) The path is relative to the location of the main configuration file. When Copper processes the configuration, it will: Read the main configuration file Process each included file Merge the included configurations according to the merging rules Parameter Substitution \u00b6 You can parameterize your included configurations using template variables that will be replaced at runtime: // included_config.ron ( tasks: [ ( id: \"task_{{instance_id}}\", // Will be replaced with the provided instance_id type: \"tasks::Task{{instance_id}}\", config: { \"param_value\": {{param_value}}, // Will be replaced with the provided param_value }, ), ], cnx: [], ) Then in your main configuration: ( tasks: [], cnx: [], includes: [ ( path: \"included_config.ron\", params: { \"instance_id\": \"42\", // Replaces {{instance_id}} with \"42\" \"param_value\": 100, // Replaces {{param_value}} with 100 }, ), ], ) Parameter Format \u00b6 Parameters use the {{parameter_name}} format and can appear in: Task IDs Task types Connection strings Configuration values (both keys and values) Parameter values can be: Strings Numbers (integers, floats) Booleans Null values Arrays Maps Merging Rules \u00b6 When merging included configurations with the main configuration, Copper follows these rules: Tasks : Tasks from included files are added to the main configuration If a task with the same ID already exists in the main configuration, the main configuration's task takes precedence Tasks from later includes override tasks from earlier includes with the same ID Connections : Connections from included files are added to the main configuration If a connection with the same source and destination already exists, the main configuration's connection takes precedence Connections from later includes override connections from earlier includes with the same source and destination Monitor and Logging : If a monitor or logging configuration is defined in the main file, it takes precedence over included configurations If the main file doesn't define a monitor or logging configuration, the first included file with such configurations is used Nested Includes \u00b6 Configuration files can include other configuration files, allowing for hierarchical composition: // main.ron ( tasks: [], cnx: [], includes: [ ( path: \"middle.ron\", params: {}, ), ], ) // middle.ron ( tasks: [ ( id: \"middle_task\", type: \"tasks::MiddleTask\", ), ], cnx: [], includes: [ ( path: \"nested.ron\", params: {}, ), ], ) // nested.ron ( tasks: [ ( id: \"nested_task\", type: \"tasks::NestedTask\", ), ], cnx: [], ) When Copper processes the configuration: 1. It will start with main.ron 2. It will include middle.ron (which includes its own task) 3. It will then include nested.ron (which includes its own task) 4. The final configuration will contain tasks from all three files Nested References \u00b6 Configuration files can include other configuration files, creating a hierarchy of configurations. Be careful when creating deeply nested configurations to avoid unintended recursion or excessive nesting, as this may impact performance. Common Use Cases \u00b6 1. Sharing Common Components \u00b6 Create a base configuration with common components: // common_sensors.ron ( tasks: [ ( id: \"imu\", type: \"sensors::IMU\", ), ( id: \"gps\", type: \"sensors::GPS\", ), ], cnx: [], ) Include it in multiple robot configurations: // robot_config.ron ( tasks: [ // Robot-specific tasks ], cnx: [ // Robot-specific connections ], includes: [ ( path: \"common_sensors.ron\", params: {}, ), ], ) 2. Environment-Specific Configurations \u00b6 Create configurations for different deployment environments: // dev_environment.ron ( tasks: [ ( id: \"camera\", type: \"sensors::MockCamera\", // Mock camera for development ), ], cnx: [], ) // prod_environment.ron ( tasks: [ ( id: \"camera\", type: \"sensors::RealCamera\", // Real camera for production ), ], cnx: [], ) Choose the appropriate environment in your main configuration: // main_config.ron ( tasks: [ // Common tasks ], cnx: [ // Common connections ], includes: [ ( path: \"dev_environment.ron\", // Change to prod_environment.ron for production params: {}, ), ], ) 3. Reusing Task Templates with Different Parameters \u00b6 Create a parameterized task template: // motor_template.ron ( tasks: [ ( id: \"motor_{{motor_id}}\", type: \"actuators::Motor\", config: { \"pin\": {{pin}}, \"direction\": \"{{direction}}\", }, ), ], cnx: [], ) Include it multiple times with different parameters: // robot_config.ron ( tasks: [], cnx: [], includes: [ ( path: \"motor_template.ron\", params: { \"motor_id\": \"left\", \"pin\": 4, \"direction\": \"forward\", }, ), ( path: \"motor_template.ron\", params: { \"motor_id\": \"right\", \"pin\": 5, \"direction\": \"reverse\", }, ), ], ) This will generate two motor tasks with different IDs, pins, and directions. Best Practices \u00b6 Organize Configuration Files : Keep related components together in the same include file Use descriptive filenames that indicate the purpose of the configuration Create a directory structure that reflects the organization of your robot Parameter Naming : Use clear, descriptive parameter names Follow a consistent naming convention Document parameters with comments in the configuration files Handling Variations : Create small, focused configuration files for specific components Use parameters for values that might change between deployments Create environment-specific configuration files for different contexts (e.g., development, testing, production) Testing : Test your configuration with different parameter values Verify that the merged configuration matches your expectations Consider creating a test that validates your configuration files Limitations \u00b6 Order Dependency : The order of includes matters, as later includes can override earlier ones. Parameter Scope : Parameters are only applied to the specific include where they're defined. If you want to use the same parameter across multiple includes, you need to specify it for each include. Error Handling : If an included file cannot be found, Copper will return an error. Make sure all included files are available at the specified paths. Examples \u00b6","title":"Modular Configuration"},{"location":"Modular-Configuration/#table-of-contents","text":"Overview Including Configuration Files Parameter Substitution Merging Rules Nested Includes Common Use Cases Best Practices Limitations Examples","title":"Table of Contents"},{"location":"Modular-Configuration/#overview","text":"As robot configurations grow more complex, it becomes important to organize and reuse configuration components. Copper's modular configuration system allows you to: Split large configurations into manageable, reusable chunks Create configuration variations without duplicating the entire RON file Parameterize configurations to handle different deployments and environments","title":"Overview"},{"location":"Modular-Configuration/#including-configuration-files","text":"You can include other RON configuration files using the includes section at the top level of your configuration: ( tasks: [ // Your main configuration tasks... ], cnx: [ // Your main configuration connections... ], includes: [ ( path: \"path/to/included_config.ron\", params: {}, // Optional parameter substitutions ), ], ) The path is relative to the location of the main configuration file. When Copper processes the configuration, it will: Read the main configuration file Process each included file Merge the included configurations according to the merging rules","title":"Including Configuration Files"},{"location":"Modular-Configuration/#parameter-substitution","text":"You can parameterize your included configurations using template variables that will be replaced at runtime: // included_config.ron ( tasks: [ ( id: \"task_{{instance_id}}\", // Will be replaced with the provided instance_id type: \"tasks::Task{{instance_id}}\", config: { \"param_value\": {{param_value}}, // Will be replaced with the provided param_value }, ), ], cnx: [], ) Then in your main configuration: ( tasks: [], cnx: [], includes: [ ( path: \"included_config.ron\", params: { \"instance_id\": \"42\", // Replaces {{instance_id}} with \"42\" \"param_value\": 100, // Replaces {{param_value}} with 100 }, ), ], )","title":"Parameter Substitution"},{"location":"Modular-Configuration/#parameter-format","text":"Parameters use the {{parameter_name}} format and can appear in: Task IDs Task types Connection strings Configuration values (both keys and values) Parameter values can be: Strings Numbers (integers, floats) Booleans Null values Arrays Maps","title":"Parameter Format"},{"location":"Modular-Configuration/#merging-rules","text":"When merging included configurations with the main configuration, Copper follows these rules: Tasks : Tasks from included files are added to the main configuration If a task with the same ID already exists in the main configuration, the main configuration's task takes precedence Tasks from later includes override tasks from earlier includes with the same ID Connections : Connections from included files are added to the main configuration If a connection with the same source and destination already exists, the main configuration's connection takes precedence Connections from later includes override connections from earlier includes with the same source and destination Monitor and Logging : If a monitor or logging configuration is defined in the main file, it takes precedence over included configurations If the main file doesn't define a monitor or logging configuration, the first included file with such configurations is used","title":"Merging Rules"},{"location":"Modular-Configuration/#nested-includes","text":"Configuration files can include other configuration files, allowing for hierarchical composition: // main.ron ( tasks: [], cnx: [], includes: [ ( path: \"middle.ron\", params: {}, ), ], ) // middle.ron ( tasks: [ ( id: \"middle_task\", type: \"tasks::MiddleTask\", ), ], cnx: [], includes: [ ( path: \"nested.ron\", params: {}, ), ], ) // nested.ron ( tasks: [ ( id: \"nested_task\", type: \"tasks::NestedTask\", ), ], cnx: [], ) When Copper processes the configuration: 1. It will start with main.ron 2. It will include middle.ron (which includes its own task) 3. It will then include nested.ron (which includes its own task) 4. The final configuration will contain tasks from all three files","title":"Nested Includes"},{"location":"Modular-Configuration/#nested-references","text":"Configuration files can include other configuration files, creating a hierarchy of configurations. Be careful when creating deeply nested configurations to avoid unintended recursion or excessive nesting, as this may impact performance.","title":"Nested References"},{"location":"Modular-Configuration/#common-use-cases","text":"","title":"Common Use Cases"},{"location":"Modular-Configuration/#1-sharing-common-components","text":"Create a base configuration with common components: // common_sensors.ron ( tasks: [ ( id: \"imu\", type: \"sensors::IMU\", ), ( id: \"gps\", type: \"sensors::GPS\", ), ], cnx: [], ) Include it in multiple robot configurations: // robot_config.ron ( tasks: [ // Robot-specific tasks ], cnx: [ // Robot-specific connections ], includes: [ ( path: \"common_sensors.ron\", params: {}, ), ], )","title":"1. Sharing Common Components"},{"location":"Modular-Configuration/#2-environment-specific-configurations","text":"Create configurations for different deployment environments: // dev_environment.ron ( tasks: [ ( id: \"camera\", type: \"sensors::MockCamera\", // Mock camera for development ), ], cnx: [], ) // prod_environment.ron ( tasks: [ ( id: \"camera\", type: \"sensors::RealCamera\", // Real camera for production ), ], cnx: [], ) Choose the appropriate environment in your main configuration: // main_config.ron ( tasks: [ // Common tasks ], cnx: [ // Common connections ], includes: [ ( path: \"dev_environment.ron\", // Change to prod_environment.ron for production params: {}, ), ], )","title":"2. Environment-Specific Configurations"},{"location":"Modular-Configuration/#3-reusing-task-templates-with-different-parameters","text":"Create a parameterized task template: // motor_template.ron ( tasks: [ ( id: \"motor_{{motor_id}}\", type: \"actuators::Motor\", config: { \"pin\": {{pin}}, \"direction\": \"{{direction}}\", }, ), ], cnx: [], ) Include it multiple times with different parameters: // robot_config.ron ( tasks: [], cnx: [], includes: [ ( path: \"motor_template.ron\", params: { \"motor_id\": \"left\", \"pin\": 4, \"direction\": \"forward\", }, ), ( path: \"motor_template.ron\", params: { \"motor_id\": \"right\", \"pin\": 5, \"direction\": \"reverse\", }, ), ], ) This will generate two motor tasks with different IDs, pins, and directions.","title":"3. Reusing Task Templates with Different Parameters"},{"location":"Modular-Configuration/#best-practices","text":"Organize Configuration Files : Keep related components together in the same include file Use descriptive filenames that indicate the purpose of the configuration Create a directory structure that reflects the organization of your robot Parameter Naming : Use clear, descriptive parameter names Follow a consistent naming convention Document parameters with comments in the configuration files Handling Variations : Create small, focused configuration files for specific components Use parameters for values that might change between deployments Create environment-specific configuration files for different contexts (e.g., development, testing, production) Testing : Test your configuration with different parameter values Verify that the merged configuration matches your expectations Consider creating a test that validates your configuration files","title":"Best Practices"},{"location":"Modular-Configuration/#limitations","text":"Order Dependency : The order of includes matters, as later includes can override earlier ones. Parameter Scope : Parameters are only applied to the specific include where they're defined. If you want to use the same parameter across multiple includes, you need to specify it for each include. Error Handling : If an included file cannot be found, Copper will return an error. Make sure all included files are available at the specified paths.","title":"Limitations"},{"location":"Modular-Configuration/#examples","text":"","title":"Examples"},{"location":"Project-Templates/","text":"Project Templates \u00b6 Copper ships templates to bootstrap new projects quickly. Use them to get a runnable task graph, logging setup, and basic app layout in minutes. Prerequisites \u00b6 Rust toolchain (rustup) cargo-generate : cargo install cargo-generate Optional: just for helper commands (see Task Automation with just ) Choose a template \u00b6 Template Use it for cu_project Single-crate project for quick experiments. cu_full Multi-crate workspace with apps/ and components/ . Generate from a local checkout \u00b6 Clone the repo and move into the templates directory: git clone https://github.com/copper-project/copper-rs cd copper-rs/templates Generate a workspace or single-crate project: # Workspace template cargo +stable generate \\ --path cu_full \\ --name my_workspace \\ --destination . \\ --define copper_source=local \\ --define copper_root_path=../.. # Single-crate template cargo +stable generate \\ --path cu_project \\ --name my_project \\ --destination . \\ --define copper_source=local \\ --define copper_root_path=../.. Move into the generated project and run it: cd ../my_workspace cargo run -p my-workspace # or for the single-crate project cd ../my_project cargo run Template variables \u00b6 copper_source=local : use the local copper-rs checkout. copper_root_path=../.. : path from the generated project back to the Copper repo root. Adjust if your layout differs. If you omit --name or --define , cargo-generate will prompt you interactively. Shortcuts \u00b6 cargo cunew is an alias for cargo generate . The templates/justfile includes just gen-workspace and just gen-project for standard names.","title":"Project Templates"},{"location":"Project-Templates/#project-templates","text":"Copper ships templates to bootstrap new projects quickly. Use them to get a runnable task graph, logging setup, and basic app layout in minutes.","title":"Project Templates"},{"location":"Project-Templates/#prerequisites","text":"Rust toolchain (rustup) cargo-generate : cargo install cargo-generate Optional: just for helper commands (see Task Automation with just )","title":"Prerequisites"},{"location":"Project-Templates/#choose-a-template","text":"Template Use it for cu_project Single-crate project for quick experiments. cu_full Multi-crate workspace with apps/ and components/ .","title":"Choose a template"},{"location":"Project-Templates/#generate-from-a-local-checkout","text":"Clone the repo and move into the templates directory: git clone https://github.com/copper-project/copper-rs cd copper-rs/templates Generate a workspace or single-crate project: # Workspace template cargo +stable generate \\ --path cu_full \\ --name my_workspace \\ --destination . \\ --define copper_source=local \\ --define copper_root_path=../.. # Single-crate template cargo +stable generate \\ --path cu_project \\ --name my_project \\ --destination . \\ --define copper_source=local \\ --define copper_root_path=../.. Move into the generated project and run it: cd ../my_workspace cargo run -p my-workspace # or for the single-crate project cd ../my_project cargo run","title":"Generate from a local checkout"},{"location":"Project-Templates/#template-variables","text":"copper_source=local : use the local copper-rs checkout. copper_root_path=../.. : path from the generated project back to the Copper repo root. Adjust if your layout differs. If you omit --name or --define , cargo-generate will prompt you interactively.","title":"Template variables"},{"location":"Project-Templates/#shortcuts","text":"cargo cunew is an alias for cargo generate . The templates/justfile includes just gen-workspace and just gen-project for standard names.","title":"Shortcuts"},{"location":"Resources/","text":"Resources \u00b6 Resources are typed runtime objects that tasks and bridges can access without going through the message graph. They are provided by resource bundles and wired by name in copperconfig.ron . Today we primarily use them to expose hardware as a HAL for embedded systems, but the same mechanism works well for \"engine services\" like memory arenas, thread pools, or reserved subsystems dedicated to specific tasks or bridges. Concept \u00b6 Bundles own the concrete resources and register them into the runtime at startup. Tasks and bridges declare the bindings they need by name, and the config maps those names to bundle_id.resource_id . Resources can be exclusive (owned by one task) or shared (borrowed or Arc ). Bundles can be mission-scoped so the same task code can run against different hardware per mission. Using resources (most users) \u00b6 1) Declare the bundles you want in the config. 2) Bind task and bridge resource names to concrete bundle.resource paths. 3) Use the bindings in your task/bridge constructor. Example copperconfig.ron snippet: ( resources: [ (id: \"board\", provider: \"board_crate::BoardBundle\"), ], tasks: [ ( id: \"telemetry\", type: \"app::TelemetryTask\", resources: { bus: \"board.telemetry_bus\" }, ), ], bridges: [ ( id: \"crsf\", type: \"cu_crsf::CrsfBridge<SerialPort, SerialError>\", resources: { serial: \"board.uart0\" }, ), ], ) The bundle provider defines the resource ids (like uart0 or telemetry_bus ), so check the board/component crate docs or the bundle source for the list. In code, either implement ResourceBindings manually or use the resources! macro for a compact declaration: use cu29::prelude::*; resources!({ bus => Borrowed<TelemetryBus>, }); impl CuTask for TelemetryTask { type Resources<'r> = Resources; // ... fn new_with(_cfg: Option<&ComponentConfig>, resources: Self::Resources<'_>) -> CuResult<Self> { Ok(Self { bus: resources.bus.0 }) } } Notes: Owned<T> means the task takes exclusive ownership (common for peripherals). Borrowed<T> (macro form) or shared Arc<T> means the resource can be reused by multiple consumers. Use missions: [...] on resource entries to scope bundles to specific missions. See Copper Configuration file Reference for the full schema. Creating or adding resources \u00b6 1) Define the resource types you want to expose (drivers, pools, arenas, handles). 2) Declare bundle IDs with bundle_resources! . 3) Implement ResourceBundle to construct resources and register them in the ResourceManager . 4) Point your config resources entries at the bundle provider path. Minimal bundle example: use cu29::resource::{ResourceBundle, ResourceManager}; use cu29::{CuResult, bundle_resources}; use std::sync::Arc; pub struct BoardBundle; bundle_resources!(BoardBundle: Uart0, TelemetryBus); impl ResourceBundle for BoardBundle { fn build( bundle: cu29::resource::BundleContext<Self>, _config: Option<&cu29::config::ComponentConfig>, manager: &mut ResourceManager, ) -> CuResult<()> { let uart_key = bundle.key(BoardBundleId::Uart0); let bus_key = bundle.key(BoardBundleId::TelemetryBus); manager.add_owned(uart_key, MyUart::new())?; manager.add_shared(bus_key, Arc::new(MyBus::new()))?; Ok(()) } } Embedded note: if you need to build resources from handles created in main (for example, HAL peripherals), use ResourceManager::add_bundle_prebuilt to insert them during runtime setup. Examples \u00b6 https://github.com/copper-project/copper-rs/tree/master/examples/cu_resources_test - End-to-end example with owned vs shared resources, mission-specific bundles, and bridge bindings. https://github.com/copper-project/copper-rs/tree/master/examples/cu_elrs_bdshot_demo - Embedded demo that wires a board resource bundle into tasks and bridges. https://github.com/copper-project/copper-rs/tree/master/examples/cu_flight_controller - Uses the resources! macro to bind board peripherals to tasks.","title":"Resources"},{"location":"Resources/#resources","text":"Resources are typed runtime objects that tasks and bridges can access without going through the message graph. They are provided by resource bundles and wired by name in copperconfig.ron . Today we primarily use them to expose hardware as a HAL for embedded systems, but the same mechanism works well for \"engine services\" like memory arenas, thread pools, or reserved subsystems dedicated to specific tasks or bridges.","title":"Resources"},{"location":"Resources/#concept","text":"Bundles own the concrete resources and register them into the runtime at startup. Tasks and bridges declare the bindings they need by name, and the config maps those names to bundle_id.resource_id . Resources can be exclusive (owned by one task) or shared (borrowed or Arc ). Bundles can be mission-scoped so the same task code can run against different hardware per mission.","title":"Concept"},{"location":"Resources/#using-resources-most-users","text":"1) Declare the bundles you want in the config. 2) Bind task and bridge resource names to concrete bundle.resource paths. 3) Use the bindings in your task/bridge constructor. Example copperconfig.ron snippet: ( resources: [ (id: \"board\", provider: \"board_crate::BoardBundle\"), ], tasks: [ ( id: \"telemetry\", type: \"app::TelemetryTask\", resources: { bus: \"board.telemetry_bus\" }, ), ], bridges: [ ( id: \"crsf\", type: \"cu_crsf::CrsfBridge<SerialPort, SerialError>\", resources: { serial: \"board.uart0\" }, ), ], ) The bundle provider defines the resource ids (like uart0 or telemetry_bus ), so check the board/component crate docs or the bundle source for the list. In code, either implement ResourceBindings manually or use the resources! macro for a compact declaration: use cu29::prelude::*; resources!({ bus => Borrowed<TelemetryBus>, }); impl CuTask for TelemetryTask { type Resources<'r> = Resources; // ... fn new_with(_cfg: Option<&ComponentConfig>, resources: Self::Resources<'_>) -> CuResult<Self> { Ok(Self { bus: resources.bus.0 }) } } Notes: Owned<T> means the task takes exclusive ownership (common for peripherals). Borrowed<T> (macro form) or shared Arc<T> means the resource can be reused by multiple consumers. Use missions: [...] on resource entries to scope bundles to specific missions. See Copper Configuration file Reference for the full schema.","title":"Using resources (most users)"},{"location":"Resources/#creating-or-adding-resources","text":"1) Define the resource types you want to expose (drivers, pools, arenas, handles). 2) Declare bundle IDs with bundle_resources! . 3) Implement ResourceBundle to construct resources and register them in the ResourceManager . 4) Point your config resources entries at the bundle provider path. Minimal bundle example: use cu29::resource::{ResourceBundle, ResourceManager}; use cu29::{CuResult, bundle_resources}; use std::sync::Arc; pub struct BoardBundle; bundle_resources!(BoardBundle: Uart0, TelemetryBus); impl ResourceBundle for BoardBundle { fn build( bundle: cu29::resource::BundleContext<Self>, _config: Option<&cu29::config::ComponentConfig>, manager: &mut ResourceManager, ) -> CuResult<()> { let uart_key = bundle.key(BoardBundleId::Uart0); let bus_key = bundle.key(BoardBundleId::TelemetryBus); manager.add_owned(uart_key, MyUart::new())?; manager.add_shared(bus_key, Arc::new(MyBus::new()))?; Ok(()) } } Embedded note: if you need to build resources from handles created in main (for example, HAL peripherals), use ResourceManager::add_bundle_prebuilt to insert them during runtime setup.","title":"Creating or adding resources"},{"location":"Resources/#examples","text":"https://github.com/copper-project/copper-rs/tree/master/examples/cu_resources_test - End-to-end example with owned vs shared resources, mission-specific bundles, and bridge bindings. https://github.com/copper-project/copper-rs/tree/master/examples/cu_elrs_bdshot_demo - Embedded demo that wires a board resource bundle into tasks and bridges. https://github.com/copper-project/copper-rs/tree/master/examples/cu_flight_controller - Uses the resources! macro to bind board peripherals to tasks.","title":"Examples"},{"location":"Roadmap/","text":"Roadmap \u00b6 This page tracks recently delivered features and items we plan to build next. Shipped \u00b6 [x] Buffer pools for zero-copy large inter-task transfers. [x] Missions to switch between multiple DAGs in a single configuration file. [x] Modular configuration with includes and parameterization. [x] ROS2/DDS interfacing with source and sink bridges. [x] Microcontroller support via no_std for bare-metal targets. Planned \u00b6 [ ] Log compression and selection to reduce log size and filter data. [ ] Parallel Copper Lists to improve throughput. [ ] Extensible scheduling hints for compile-time optimization. [ ] Swarm support using Zenoh (sink done, needs source). [ ] MCAP support for Foxglove and ROS logging interoperability.","title":"Roadmap"},{"location":"Roadmap/#roadmap","text":"This page tracks recently delivered features and items we plan to build next.","title":"Roadmap"},{"location":"Roadmap/#shipped","text":"[x] Buffer pools for zero-copy large inter-task transfers. [x] Missions to switch between multiple DAGs in a single configuration file. [x] Modular configuration with includes and parameterization. [x] ROS2/DDS interfacing with source and sink bridges. [x] Microcontroller support via no_std for bare-metal targets.","title":"Shipped"},{"location":"Roadmap/#planned","text":"[ ] Log compression and selection to reduce log size and filter data. [ ] Parallel Copper Lists to improve throughput. [ ] Extensible scheduling hints for compile-time optimization. [ ] Swarm support using Zenoh (sink done, needs source). [ ] MCAP support for Foxglove and ROS logging interoperability.","title":"Planned"},{"location":"SDK-Features/","text":"SDK Features \u00b6 Copper ships with a set of runtime and tooling capabilities designed for deterministic robotics applications. Core features \u00b6 Task interface and lifecycle traits for implementing algorithms, sensors, and actuators. Compile-time runtime generation for deterministic scheduling. Log reader for exporting logs to formats supported by Rust Serde. Structured log reader with compile-time string interning. Component ecosystem with drivers, algorithms, and standard interfaces. Deterministic log replay and resimulation. Simulation support for testing before hardware is ready. See Available Components for the current component list.","title":"SDK Features"},{"location":"SDK-Features/#sdk-features","text":"Copper ships with a set of runtime and tooling capabilities designed for deterministic robotics applications.","title":"SDK Features"},{"location":"SDK-Features/#core-features","text":"Task interface and lifecycle traits for implementing algorithms, sensors, and actuators. Compile-time runtime generation for deterministic scheduling. Log reader for exporting logs to formats supported by Rust Serde. Structured log reader with compile-time string interning. Component ecosystem with drivers, algorithms, and standard interfaces. Deterministic log replay and resimulation. Simulation support for testing before hardware is ready. See Available Components for the current component list.","title":"Core features"},{"location":"Supported-Platforms/","text":"Copper can be deployed on: Linux x86_64 armv7 aarch64 riscv64 macOS arm64 Windows x86_64 Android arm64 But can ALSO run baremetal on microcontrollers. Here it is on our reference platform based on the RP2350, see Copper baremetal development if you are interested to deploy Copper as an actual Operating System.","title":"Supported Platforms"},{"location":"Task-Automation-with-Just/","text":"Task Automation with just \u00b6 Copper uses just to keep common tasks repeatable. just looks for the nearest justfile , so run it from the project directory you want to work in. Install \u00b6 Follow the installation instructions in the just README for your platform. Discover commands \u00b6 just -l Where to run just \u00b6 Repo root: CI and lint helpers. Examples: examples/cu_caterpillar examples/ros_caterpillar examples/ros_zenoh_caterpillar examples/cu_rp_balancebot examples/cu_elrs_bdshot_demo examples/cu_standalone_structlog Components: components/sources/cu_ads7883 components/sinks/cu_rp_sn754410 components/payloads/cu_ros_payloads Support utilities: support (general deploy/sdcard) support/docker (build/run dev containers)","title":"Task Automation with just"},{"location":"Task-Automation-with-Just/#task-automation-with-just","text":"Copper uses just to keep common tasks repeatable. just looks for the nearest justfile , so run it from the project directory you want to work in.","title":"Task Automation with just"},{"location":"Task-Automation-with-Just/#install","text":"Follow the installation instructions in the just README for your platform.","title":"Install"},{"location":"Task-Automation-with-Just/#discover-commands","text":"just -l","title":"Discover commands"},{"location":"Task-Automation-with-Just/#where-to-run-just","text":"Repo root: CI and lint helpers. Examples: examples/cu_caterpillar examples/ros_caterpillar examples/ros_zenoh_caterpillar examples/cu_rp_balancebot examples/cu_elrs_bdshot_demo examples/cu_standalone_structlog Components: components/sources/cu_ads7883 components/sinks/cu_rp_sn754410 components/payloads/cu_ros_payloads Support utilities: support (general deploy/sdcard) support/docker (build/run dev containers)","title":"Where to run just"},{"location":"Task-Lifecycle/","text":"Copper: Task Lifecycle \u00b6 Here is a quick illustration of a task lifecycle \u00b6 The framework is designed to give as many chances as possible for the tasks to do its heavy lifting out of the critical path. The time critical part will try to be scheduled as back to back as possible between tasks on the same thread (low latency / low jitter) The best effort part will try be scheduled by packing them to minimize the interference with the critical path (high throughput / high jitter). In the critical loop, no allocation should occur, messages are pre-allocated and reused. Note on freeze / thaw: A task internal state can be serialized to give the opportunity for the framework to \"snapshot\" the system, it would be at a low rate (ie. ~ a second). You can think of it a little bit as a \"key frame\" in a video. It is useful at replay to be able to jump into a state without having to replay all the previous messages.","title":"Copper Tasks lifecycle overview"},{"location":"Task-Lifecycle/#copper-task-lifecycle","text":"","title":"Copper: Task Lifecycle"},{"location":"Task-Lifecycle/#here-is-a-quick-illustration-of-a-task-lifecycle","text":"The framework is designed to give as many chances as possible for the tasks to do its heavy lifting out of the critical path. The time critical part will try to be scheduled as back to back as possible between tasks on the same thread (low latency / low jitter) The best effort part will try be scheduled by packing them to minimize the interference with the critical path (high throughput / high jitter). In the critical loop, no allocation should occur, messages are pre-allocated and reused. Note on freeze / thaw: A task internal state can be serialized to give the opportunity for the framework to \"snapshot\" the system, it would be at a low rate (ie. ~ a second). You can think of it a little bit as a \"key frame\" in a video. It is useful at replay to be able to jump into a state without having to replay all the previous messages.","title":"Here is a quick illustration of a task lifecycle"}]}